@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>

> ![ATTENTION]常用的方法策略：
>
> 1、回溯法
>
> 2、分治法
>
> 3、动态规划：明显的选和不选的问题来获取一个最优值的问题，归结为动态规划的问题--->状态转移矩阵
>
> 一般问策略的时候，都是上面三种选一个。
>
> 递归和非递归只是实现方式。
>
> 1、自顶向下-递归实现方式，时间复杂度一般为O(2n)
>
> 2、自底向上-非递归实现方式，只是用了数组保存递归中会出现的一些重复计算，用空间换时间。

## N皇后问题【回溯法】

![A33000D5-3EF4-423F-9068-3CBA2EAED75D](16%E7%AE%97%E6%B3%95.assets/A33000D5-3EF4-423F-9068-3CBA2EAED75D.png)

思路：按照行来摆放皇后，摆完第一行、摆第二行…..第n+1行不能摆放时，回溯到上一行

一般用一维数组Q[n]表示结果，因为按行摆放，Q[i]表示第i个皇后在i行Q[i]列。

**4皇后的解决方案有2个…要记住[2,4,1,3]\[3,1,4,2]**

###  非递归方法

----> 循环迭代

```java
public static void queen() {

​    // 初始化棋盘

​    for (int i = 1; i <= N; i++) {

​      q[i] = 0;

​    }

​    int j = 1; // 表示摆放第 j 个皇后

​    while (j >= 1) { // 防止回溯时溢出

​      // 让该皇后按列摆放

​      q[j] = q[j] + 1;

​      // 判断皇后位置是否合法且不越界

​      while (q[j] <= N && !check(j)) {

​        q[j] = q[j] + 1;  // 不合法就往下一个位置摆放

​      }

​      if (q[j] <= N) {

​        // 第j个找到合法位置

​        if (j == N) { // 找到一组解

​          answer++;

​          System.out.print("方案" + answer + ": ");

​          for (int i = 1; i < q.length; i++) {

​            System.out.print(q[i] + " ");

​          }

​          System.out.println();

​        } else { // 继续摆放

​          j = j + 1;

​        }

​      } else {

​        // 还原第j个皇后的位置

​        q[j] = 0;

​        // 第j个找不到合法位置,回溯到上一个皇后的位置

​        j = j - 1;

​      }

​    }

  }
```

### 1.2 递归方法

---- > 是指在函数的定义中使用函数自身的方法

```java

public static void queen(int j) {

​    for (int i = 1; i <= N; i++) {

​      q[j] = i;     // 每行都循环按列摆放

​      if (check(j)) {  // 不冲突则检查是否摆放完成，否则摆放下一个

​        if (j == N) { // 摆放完成

​          answer();

​        } else {   // 摆放下一个

​          queen(j + 1);

​        }

​      }

​    }

  }
```
## 分治法

将一个难以解决的大问题分解成规模较小的**相同独立的问题**。

一般来说，分治算法在每一层递归上都有3个步骤。

（1）分解。将原问题分解成一系列子问题。

（2）求解。递归地求解各子问题。若子问题足够小，则直接求解。

（3）合并。将子问题的解合并成原问题的解。

###  递归实现

1、边界条件

2、递归模式

## 动态规划

动态规划法与分治法类似，其基本思想也是将待求解问题分解成若干入子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

与分治法不同的是，适合用动态规划法求解的问题，经分解得到的子问题往往不是独立的。

若用分治法来解这类问题，则相同的子问题会被求解多次，以至于最后解决原问题需要耗费指数级时间。如果能够保存已解决的子问题的客案，在需要时再找出己求得的答案，这样就可以避免大量的重复计算，从而得到多项式时间的算法。为了达到这个自的，可以用一个表来记录所有已解决的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。

动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解，每个解都对应于一个值，我们希望找到具有最优值（最大值或最小值）的那个解。当然，最优解可能会有多个，动态规划法能找出其中的一个最优解。设计一个动态规划法，通常按照以下几个步骤进行。

（1）找出最优解的性质，并刻画其结构特征。

（2）递归地定义最优解的值。

（3）**以自底向上的方式计算出最优值**。

（4）根据计算最优值时得到的信息，构造一个最优解。



### 0-1背包

 ![B6B21342-D299-4C4A-A200-30739B710ADB](16%E7%AE%97%E6%B3%95.assets/B6B21342-D299-4C4A-A200-30739B710ADB.png)

时空间复杂度：O(N x W)



> ![ATTENTION]思路：
>
> 明显的选和不选的问题来获取一个最优值的问题，归结为动态规划的问题
>
> 1.定义f[i] [j]表示的是什么意义,i是什么，j是什么,f[i][j]是什么  
>
> 2. 在f[i] [j]表示这种含义下，最终的结果输出是什么？i\j分别取什么值，f[?][?]还是max(f[?] [?=?])？  
>
> 3. 寻找f[i][j]的状态转移方程，以及方程中需要满足的条件  
> 4. 寻找f[i][j]在出口值是什么  
> 5. 定义数组，实现上述思想\



确定边界和递推表达式，<font color=red>从后向前[n的状态用n-i的状态进行推导]，此刻的选择只和之前的选择有关，和之后无关</font>

如果要实现当前在n的状态，可以从之前n-i的状态转换等等… 

重点有两个，一个是只和之前的状态有关，一个是假定之前的递归函数值是已知的。 

f(n)表示状态为n时，题目描述要求的结果值。

写代码的时候，使用数组代替递归，**从前向后循环[从i=0开始循环]**，从已经知道的条件开始向后推 

如果递推表达式是两个参数的话，要使用二维数组 

如果递推表达式是一个参数，使用一维数组

针对上面的思路步骤我们一步步来：

1. f[i][j]，I表示正在选择第I个商品[选/不选]，背包容量为j,最大价值为f[i][j]
2. 输出结果时，i=n，j < n；取f[n][x]的最大值。
3. 状态转移矩阵，在第i个商品面临一个选、一个不选的问题【当背包容量不足时不选；背包容量足时比较选了和不选择最大值】，注意是从后往前

![F45B14F7-A609-4C4E-8EDB-A077452F6A34](16%E7%AE%97%E6%B3%95.assets/F45B14F7-A609-4C4E-8EDB-A077452F6A34.png)

1. 出口值，f [0] [0] = 0

   
```java
int N = 4; // 物品数量

​    int W = 5; // 背包容量

​    int[] v = {0, 2, 4, 5, 6};  // 物品价值数组

​    int[] w = {0, 1, 2, 3, 4};  // 物品重量数组

​    int[][] f = new int[N + 1] [W + 1]; // 子问题解数组；记录状态转移方程的数组**result[number+1] [col+1]**，是因为需要result[0]表示的是没有任何元素时，表示的是实际的0

​    for (int i = 1; i <= N; i++) {   // 物品编号

​      for (int j = 1; j <= W; j++) { // 背包容量

​        if (j >= w[i]) { // 选择当前物品

​          // (上一个物品的最优解) 比较 (当前物品价值+剩余容量在上一个物品的最优解)

​          f[i][j] = Math.max(f[i - 1] [j], v[i] + f[i - 1] [j - w[i]]);

​        } else { // 不选择当前物品

​          // 直接使用上一个物品的最优解

​          f[i][j] = f[i - 1][j];

​        }

​      }

​    }
```
当然也可以优化成用一个一维数组，用temp保留计算第i个物品中的过程数据：
```java

int[] result = new int[volume+1];

result[0] = 0;

for (int i = 1; i <= number; i++) {

  int temp = 0;

  for (int j = volume; j >= volumes[i-1]; j--) {

​    temp = Math.max(result[j],result[j - volumes[i-1]]+values[i-1]);

  }

  result[j] = temp;

}
```
## 贪心（概念了解）

![F1CA49B1-4F1F-46CD-92E9-70165CF8A446](16%E7%AE%97%E6%B3%95.assets/F1CA49B1-4F1F-46CD-92E9-70165CF8A446.png)

## 分支限界（概念了解）

![5088D291-FC6C-4979-A0FF-FC30A83D2DF8](16%E7%AE%97%E6%B3%95.assets/5088D291-FC6C-4979-A0FF-FC30A83D2DF8.png)

## C语言的注意点

1. 对于int i,j=1;注意的是，只有j被赋值为1了，i只有定义，没有赋值。
2. 对于数组int a[N]，如果想传参整个数组的话，直接传a
3. 

