@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>

## 数据类型

### 整型

TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。

INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义。

### 浮点数

FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。

FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。

### 字符串

CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。

#### VARCHAR

VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。

下面这些情况使用VARCHAR是合适的：

- 字符串的最大长度比平均长度大很多；
- 列的更新很少，所以碎片不是问题；
- 使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储。

> 使用VARCHAR(5)和VARCHAR(200)存储"hello"的空间开销是一样的。那么使用更短的列有什么优势吗？
>
> 事实证明有很大的优势。更长的列会消耗更多的内存，因为MySQL通常会分配固定大小的内存块来保存内部值。尤其是使用内存临时表进行排序或其他操作时会特别糟糕。在利用磁盘临时表进行排序时也同样糟糕。
>
> 所以最好的策略是只分配真正需要的空间。

#### CHAR

当存储CHAR值时，MySQL会删除所有的末尾空格。CHAR值会根据需要采用空格进行填充以方便比较。

CHAR适合存储很短的字符串，或者所有值都接近同一个长度，如密码的MD5值。对于经常变更的数据，CHAR也比VARCHAR更好，因为CHAR不容易产生碎片。

### 日期

#### 1. DATETIME

能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。

它与时区无关。

默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。

#### TIMESTAMP

和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜(格林威治时间)以来的秒数，使用 4 个字节，只能表示从 1970 年 到 2038 年。

它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。

MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。

默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。

应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。

### 大对象

BLOB和TEXT都是为存储很大的数据而设计的数据类型，分别采用二进制和字符方式存储。

与其他类型不同，MySQL把每个BLOB和TEXT值当做一个独立的对象去处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。

MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length个字节而不是整个字符串做排序。同样的，MySQL也不能将BLOB或TEXT列全部长度的字符串进行索引。

### 总结

- 数字型

| 类型         | 大小(字节)                               | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| :----------- | :--------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :-------------- |
| TINYINT      | 1 Bytes                                  | (-128，127)                                                  | (0，255)                                                     | 小整数值        |
| SMALLINT     | 2 Bytes                                  | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |
| MEDIUMINT    | 3 Bytes                                  | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |
| INT或INTEGER | 4 Bytes                                  | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |
| BIGINT       | 8 Bytes                                  | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |
| FLOAT        | 4 Bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| DOUBLE       | 8 Bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |

- 字符型

| 类型       | 大小（字节）          | 用途                            |
| :--------- | :-------------------- | :------------------------------ |
| CHAR       | 0-255 bytes           | 定长字符串                      |
| VARCHAR    | 0-65535 bytes         | 变长字符串                      |
| TINYBLOB   | 0-255 bytes           | 不超过 255 个字符的二进制字符串 |
| TINYTEXT   | 0-255 bytes           | 短文本字符串                    |
| BLOB       | 0-65 535 bytes        | 二进制形式的长文本数据          |
| TEXT       | 0-65 535 bytes        | 长文本数据                      |
| MEDIUMBLOB | 0-16 777 215 bytes    | 二进制形式的中等长度文本数据    |
| MEDIUMTEXT | 0-16 777 215 bytes    | 中等长度文本数据                |
| LONGBLOB   | 0-4 294 967 295 bytes | 二进制形式的极大文本数据        |
| LONGTEXT   | 0-4 294 967 295 bytes | 极大文本数据                    |

- 日期型

| 类型      | 大小 ( bytes) | 范围                                                         | 格式                | 用途                     |
| :-------- | :------------ | :----------------------------------------------------------- | :------------------ | :----------------------- |
| DATE      | 3             | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |
| TIME      | 3             | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |
| YEAR      | 1             | 1901/2155                                                    | YYYY                | 年份值                   |
| DATETIME  | 8             | '1000-01-01 00:00:00' 到 '9999-12-31 23:59:59'               | YYYY-MM-DD hh:mm:ss | 混合日期和时间值         |
| TIMESTAMP | 4             | '1970-01-01 00:00:01' UTC 到 '2038-01-19 03:14:07' UTC结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYY-MM-DD hh:mm:ss | 混合日期和时间值，时间戳 |

## 存储过程和函数

<font color=red>**存储过程是用户定义的一系列SQL语句的集合，可以指定输入参数、输出参数、返回单个或者多个的结果集，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。**</font>

### 存储过程

#### 基本语法

##### 定义存储过程

一些关键语法：

1. DELIMITER xx 定义整个存储过程的结束符为xx `DELIMITER //  定义存储过程结束符号为//`

   > MySQL默认以";"为分隔符，如果没有声明分割符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错
   >
   > 所以要事先用“DELIMITER //”声明当前段分隔符，让编译器把两个"//"之间的内容当做存储过程的代码，不会执行这些代码；“DELIMITER ;”的意为把分隔符还原。

2. 存储过程定义整体

   ```sql
   CREATE PROCEDURE 存储过程名(定义输入输出参数) [ 存储特性 ]  
   BEGIN 
   		SQL语句；  
   END 存储过程结束符 
   ```

   1. 定义参数：[IN |OUT |INOUT ]  参数名 参数数据类型
   2. IN 表示输入参数，OUT表示输出参数，INOUT表示既可以输入也可以输出的参数。
   3. `IN stuId INT(11)`
   4. 存储特性：
      1. LANGUAGE SQL：说明存储过程实体部分是由SQL语言的语句组成，这也是数据库系统默认的语言。
      2. [NOT] DETERMINISTIC：指明存储过程的执行结果是否是确定的。DETERMINISTIC表示结果是确定的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是非确定的，相同的输入可能得到不同的输出。默认情况下，结果是非确定的。
      3. { CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA }：指明子程序使用SQL语句的限制。CONTAINS SQL表示子程序包含SQL语句，但不包含读或写数据的语句；NO SQL表示子程序中不包含SQL语句；READS SQL DATA表示子程序中包含读数据的语句；MODIFIES SQL DATA表示子程序中包含写数据的语句。默认情况下，系统会指定为CONTAINS SQL。
      4. SQL SECURITY { DEFINER | INVOKER }：指明谁有权限来执行。DEFINER表示只有定义者自己才能够执行；INVOKER表示调用者可以执行。默认情况下，系统指定的权限是DEFINER。
      5. COMMENT 'string'：注释信息。

```sql
DELIMITER //
 CREATE PROCEDURE myproc(OUT s int)
  BEGIN
   SELECT COUNT(*) INTO s FROM students;
  END
  //
DELIMITER ;
```

注意的问题：

1. 在存储过程中使用select语句时要紧接into，select xxx into 变量1，变量2 from....将查询结果放置到变量中

2. 在存储过程中如果select结果为空，则会抛出异常 no data found

   ```sql
   BEGIN 
   	SELECT COL1,COL2 INTO 变量1，变量2 FROM xxx
   	EXCEPTION
   	WHEN NO_DATA_FOUND THEN
   	xxx;
   END//
   ```

##### 调用存储过程

调用存储过程

```
call 存储过程名(参数1，参数2，....);
```

注意：

1. 用户变量名一般以@开头
2. 传递的参数列表是存储过程定义的参数列表（包括入参、出参等等）
3. 之后采用`select 出参数名`获取结果

##### 删除存储过程

```
DROP PROCEDURE 数据库.存储过程名;
```

#####  存储过程的查看与修改

查看某个数据库下的存储过程：

```sql
show procedure status where db='数据库名';
```

查看每个存储过程具体的创建语句：

```
SHOW CREATE PROCEDURE 数据库.存储过程名;
```

修改某个存储过程的定义信息：

```
ALTER PROCEDURE
```

### 函数

#### 语法

##### 定义存储函数

```sql
CREATE FUNCTION 函数名 (函数入参列表) RETURNS 返回值类型 [存储特性]
BEIGIN
	SQL语句
END 函数结束符 
```

1. 函数入参列表 `参数名 数据类型`，因为都是入参，不需要IN
2. SQL语句中一定有一个RETURN

```sql
DELIMITER && 
CREATE FUNCTION name_from_employee (emp_id INT ) RETURNS VARCHAR(20) 
BEGIN
  RETURN (SELECT name
  FROM employee 
  WHERE num=emp_id ); 
END&& 
DELIMITER ;
```

##### 调用存储函数

方式一：用在select语句

```
select 函数名（参数）
```

方式二：赋值给变量

```
set 变量 = 函数名（参数）
```

### 存储过程和函数优点

存储过程和函数都是存储在数据库中的SQL集合，又用户直接或者间接调用，具有以下优点：

1. 增强了SQL语言的灵活性和功能性，可以完成比较复杂的判断和运算。
2. 可以重复使用，减少数据库开发人员的工作量。
3. 存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL 语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。
4. 当对数据库进行复杂操作时(如对多个表进行Update,Insert,Query,Delete 时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。这些操作，如果用程序来完成，就变成了一条条的SQL语句，可能要多次连接数据库。而换成存储，只需要连接一次数据库就可以了。
5. 可以将相关的动作一起发生，维护数据库的完整性。
6. 降低网络通信量，不需要网络传递很多的SQL语句到达数据库服务器。
7. 保证数据库的安全，通过SQL SECURITY可以令没有权限的用户在权限控制下间接读取数据库数据。

### 存储过程和函数区别

本质上，存储过程和函数没有什么区别，只是在使用下有些区别：

1. 标志符不同，函数标志符为FUNCTION，存储过程标志符为PROCEDURE。
2. 两者返回值不同：函数必须有返回值，且只能有一个；存储过程可以无或者有多个返回值。
3. 两者调用方式不同：存储过程没有返回值类型，需要利用call函数调用作为一个独立部分执行，不能直接赋值给变量；函数有返回值类型，除了可以赋值给变量还可以直接在select子句中使用。
4. 总体来讲，存储过程的限制相对就比较少 ，可实现的功能复杂一些。

### 游标

游标只能用在存储过程或者函数之中，在存储过程的SQL语句中使用游标进行循环。

游标实际上是一种能从包括多条数据记录的结果集中每次提取一条记录的机制，充当指针的作用，一次只指向一行结果。

    游标充当指针的作用。

#### 游标的使用

1. 在一个存储过程或者函数的Begin/End中使用

2. 声明一个游标: declare 游标名 CURSOR for table;(这里的table可以是你查询出来的任意集合)

   ```
   declare cur cursor for select name,count from store where name = 'iphone';  
   ```

3. 打开定义的游标:open 游标名;

   ```
    open cur;  
   ```

4. 循环获取获得下一行数据:FETCH  游标名 into testrangeid,versionid;

   ```sql
   read_loop:loop  //开始循环
   fetch cur into n,c;  
   set total = total+c;  
   end loop; 
   ```

5. 需要执行的语句(增删改查):这里视具体情况而定

6. 释放游标:CLOSE 游标名;

```sql
CREATE PROCEDURE StatisticStore()  
BEGIN  
    --创建接收游标数据的变量  
    declare c int;  
    declare n varchar(20);  
    --创建总数变量  
    declare total int default 0;  
    --创建结束标志变量  
    declare done int default false;  
    --创建游标  
    declare cur cursor for select name,count from store where name = 'iphone';  
    --指定游标循环结束时的返回值  
    declare continue HANDLER for not found set done = true;  
    --设置初始值  
    set total = 0;  
    --打开游标  
    open cur;  
    --开始循环游标里的数据  
    read_loop:loop  
    --根据游标当前指向的一条数据  
    fetch cur into n,c;  
    --判断游标的循环是否结束  
    if done then  
        leave read_loop;    --跳出游标循环  
    end if;  
    --获取一条数据时，将count值进行累加操作，这里可以做任意你想做的操作，  
    set total = total + c;  
    --结束游标循环  
    end loop;  
    --关闭游标  
    close cur;  

    --输出结果  
    select total;  
END;  
```

#### 如何知道游标到了最后

```
declare continue HANDLER for not found set done = true; 
```

在MySql中，造成游标溢出时会引发mysql预定义的NOT FOUND错误，所以在上面使用下面的代码指定了当引发not found错误时定义一个continue 的事件，指定这个事件发生时修改done变量的值。

在循环时加上了下面这句代码：

```sql
--判断游标的循环是否结束  
if done then  
    leave read_loop;    --跳出游标循环  
end if;  
```

#### 游标的优缺点

优点：

1. 游标允许定位在结果集的某个特定行
2. 支持结果集从当前行进行数据修改
3. 使用游标可以针对结果集的多个行执行多个不相关的操作

缺点：

1. 游标的缺点是针对有点而言的，也就是只能一行一行操作，在数据量大的情况下，是不适用的，**速度过慢**。
2. 当数据量大时，使用游标会造成内存不足现象。

使用场景：

主要**用在循环处理、存储过程、函数中使用**，用来查询结果集的场景。

## 触发器

触发器（trigger）是数据库提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行是由事件来触发，比如当对一个表进行操作（insert，delete， update）时就会激活它执行。

### 语法

#### 创建触发器

```sql
create trigger 触发器名 before|after 事件 on 表名 for each row 
begin
触发器语句;
end 存储过程结束符 
```

1. 触发器名建议为trigger_xxx，这样便于区分，触发器名不能重复。
2. before|after 代表触发器语句执行时间，如果是before,就是在insert delete update操作之前执行触发器语句；after就是之后。
3. 事件就是insert delete update操作中的一个。
4. for each row 是代表任何记录执行对应操作都会触发器。
5. 触发器语句就是触发器触发时要执行的语句。
6. 使用odl\new.字段名来引用数据，new是新插入的数据，old是原来的数据。

```sql
delimiter  $$ -- 一般定义成$$
create trigger trigger_addUserTime23 before insert on user_info for each row 
begin 
insert into usercreatetime(create_time) values(now());
insert into usercreatetime(create_time) values(now());
end $$
delimiter ;
```

####  触发器维护

1. 使用`show triggers\G` 查看所有触发器
2. 查看触发器创建语句：`show create trigger 触发器名\G;`
3. 使用`drop trigger 触发器名;`来删除触发器

### 触发器的作用

1. 可维护数据库的安全性、一致性和完整性
2. 在写入数据表之前，强制检验或者转换数据
3. 当触发器发生错误时，异常的结果可撤销

### 触发器的缺点

1. 滥用会造成数据库和应用程序的维护困难
2. 触发器是被事件被动触发的，且不能接收参数

### 触发器和存储过程的不同

1. 存储过程是由用户或者应用程序显式调用的，触发器是由一个事件触发自动隐式运行
2. 存储过程可以接收返回参数，触发器不能接收参数。

## 视图

视图是一个虚拟的表，是从数据库的基本表中选取出的数据组成的逻辑窗口。在数据库中存放的只是视图的定义，不存放任何数据，只有在使用视图时才会执行视图的定义并从基础表中查询数据动态生成视图。

### 视图的分类

1. 简单视图：基于单个表所建立的视图，不包含任何函数、表达式及分组数据的视图

2. 复杂视图：包含函数、表达式及分组数据的视图

3. 连接视图：基于多表所建立的视图

4. 只读视图：只允许执行查询操作

5. 内联视图：出现在FROM的子查询，并不属于一个数据库对象

   ```sql
   FROM (SELECT product_spec_id AS tax_amount_money FROM `c` ) 
   ```

### 语法

#### 定义视图

定义视图可以来自当前数据库或其他数据库的一个或多个表，或者其他视图。

分布式查询也可以定义使用多个异源数据的视图。

定义一个视图必须拥有CREATE VIEW的系统权限，如果在其他用户中创建视图，需要由CREATE ANY VIEW的权限

```sql
CREATE [ON REPLACE] [FORCE] [ALGORITHM]={UNDEFINED|MERGE|TEMPTABLE}]
VIEW 视图名 <属性清单>
AS SELECT语句
[WITH [CASCADED|LOCAL] CHECK OPTION];
```

1. 创建视图：
   1. CREATE：创建一个视图，有同名的视图则报错
   2. CREATE ON REPLACE：如果有同名的视图替换重构
2. FORCE ：强制创建视图，不考虑基表是否存在，不考虑是否有基表的权限
3. ALGORITHM有三个参数分别是：merge、TEMPTABLE、UNDEFINED
   1. merge：处理方式替换式，可以进行更新真实表中的数据；
   2. TEMPTABLE：临时表模式，每当查询的时候，将视图所使用的select语句生成一个结果的临时表，再在当前的临时表内进行查询。Temptable这种方式没办法更新。
   3. UNDEFINED(没有定义ALGORITHM参数),mysql更倾向于选择替换方式，是因为它更加有效。
4. WITH CASCADED CHECK OPTION：表示更新视图时要满足所有相关视图和表的条件
5. WITH LOCAL CHECK OPTION：表示更新视图时满足该视图本身的定义的条件即可

#### 查看视图

1. 查看视图 `desc 视图名`

2. 查看视图 `show table status like '视图名'`

3. `show create view 视图名`

4. 修改视图 `alter view 视图名`

5. 删除视图 `drop view [if exists] 视图名`，只有视图所有者和具备DROP VIEW权限的用户才能删除视图，删除视图只是删除视图的定义，原有表的数据并不受影响。

### 视图的优缺点

优点：

1. 可以允许简化结构，执行复杂查询操作。
2. 隐藏了数据复杂性，作为外模式，提供了一定程度的逻辑独立性。
3. 有助于限制对特定用户的数据访问，可以使用数据库视图将非敏感数据仅显示给特定用户组。
4. 提供额外的安全性， 数据库视图允许创建只读视图，以将只读数据公开给特定用户。 

缺点：

1. 性能：视图的执行过程是先执行视图定义，将其结果使用临时表保存起来，这样后续对视图的操作就转化为对临时表的操作，从数据库视图查询数据可能会很慢，特别是如果视图是基于其他视图创建的。
2. 表依赖关系：将根据数据库的基础表创建一个视图。每当更改与其相关联的表的结构时，都必须更改视图。

### 使用视图时的注意点

1. 普通视图执行DML语句没有限制，对视图的操作实际上是改变基表（视图定义中涉及的表）的数据。
2. 若视图中包含GROUP BY、DISTINCT关键字，不能执行DELETE操作。
3. 视图有以下情况时，视图中不能执行UPDATE和INSERT操作：
   1. 视图中包含GROUP BY、DISTINCT关键字
   2. 视图中包含由表达式定义的列
   3. 基表中未被视图选择的列是非空的，且无默认值

### 视图和表的区别

1. 视图是已经编译好的SQL语句，是基于SQL语句的结果集的可视化的虚表，而表属于全局模式中的表，是实表
2. 表是内容，视图是窗口
3. 表占用物理空间而视图不占用物理空间，视图只是逻辑概念的存在
4. 表可以及时对它进行修改，但视图只能用创建的语句来修改视图
5. 视图是查看数据表的一种方法，可以查询数据表中的某些字段构成的数据，只是一些SQL语句的集合
6. 从安全的角度讲，视图可以防止用户接触数据表，因而用户不知道表结构

## 存储引擎

### InnoDB

是 MySQL 默认的事务型存储引擎，**只有在需要它不支持的特性时，才考虑使用其它存储引擎**。

实现了四个标准的隔离级别，默认级别是可重复读(REPEATABLE READ)。在可重复读隔离级别下，通过多版本并发控制(MVCC)+ 间隙锁(Next-Key Locking)防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

###  MyISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

**不支持事务**。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入(CONCURRENT INSERT)。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

### 比较

- 事务: InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。
- 并发: MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。
- 外键: InnoDB 支持外键。
- 备份: InnoDB 支持在线热备份。
- 崩溃恢复: MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。
- 其它特性: MyISAM 支持压缩表和空间数据索引。

## InnoDB的存储结构 //need more details

### 存储目录

先用一个例子，看InnoDB在磁盘中存储了什么文件。

#### 数据目录

可以通过 `datadir` 这个系统变量查看MySQL的数据目录位置，默认是在 `/var/lib/mysql` 下。

```sql
mysql> show variables like 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-------------
```

在一个全新安装的数据库的数据目录下，可以看到如下的一些初始化的文件和目录。

![image-20231218182942073](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218182942073.png)

这里重点看到这几个文件：

- ibdata1：共享表空间文件
- ib_logfile0、ib_logfile1 ： redo 日志文件
- `f4e2d8fde38c.pid` 的文件：当MySQL实例启动时，会将自己的进程ID写入一个pid文件。该文件可由参数`pid_file`控制，默认位于数据库目录下，文件名为`主机名.pid`，也可以用SQL查询出来。

```sql
mysql> show variables like 'pid_file';
+---------------+---------------------------------+
| Variable_name | Value                           |
+---------------+---------------------------------+
| pid_file      | /var/lib/mysql/f4e2d8fde38c.pid |
+---------------+---------------------------------+
```

#### 数据库目录

MySQL默认创建了四个系统数据库，除了 `information_schema`，另外三个都会有一个目录与之对应。

```sql
mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
```

##### 新建数据库

通过 `create database xx;` 创建一个测试数据库，并指定了字符集为 `utf8mb4`：

```sql
mysql> create database test default character set utf8mb4;
Query OK, 1 row affected (0.00 sec)

mysql> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| test               |
+--------------------+
```

创建数据库后就会看到多了一个同名的目录，也就是说<font color=red>**MySQL中的数据库在文件系统中其实就是数据目录下的一个子目录。**</font>

![image-20231218183224671](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218183224671.png)

进入数据库目录下可以看到，创建数据库时会同步创建一个名为 `db.opt` 的文件，这个文件中包含了该数据库的各种属性，比如说该数据库默认的字符集和比较规则等。

![image-20231218183254355](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218183254355.png)

##### 系统数据库

前边提到了MySQL的几个系统数据库，下面简单看下每个数据库都是干什么的。

- `mysql`

这个数据库的核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。

- `information_schema`

这个数据库保存着MySQL服务器所有其他数据库的信息，比如表、视图、触发器、列、索引、锁、事务等等。这些信息并不是真实的用户数据，而是一些描述性信息，也称之为元数据。

- `performance_schema`

这个数据库主要保存MySQL服务器运行过程中的一些状态信息，包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。

- `sys`

这个数据库主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，让程序员可以更方便的了解MySQL服务器的一些性能信息。

#### 数据库目录下的文件

##### 定义表文件

接着回到在 test 数据库下，创建一张 `user` 表，指定的存储引擎为 InnoDB：

```sql
CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(60) NOT NULL COMMENT '用户名',
  `nickname` varchar(240) DEFAULT NULL COMMENT '昵称',
  `age` int(11) DEFAULT NULL COMMENT '年龄',
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_uk_username` (`username`) USING BTREE
) ENGINE=InnoDB;
```

创建完成之后就可以看到这张表了：

```sql
sql
复制代码mysql> show tables;
+----------------+
| Tables_in_test |
+----------------+
| user           |
+----------------+
```

此时test目录结构为![image-20231218183802686](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218183802686.png)

发现多了两个文件：

- `user.frm`：表结构定义文件，格式为 `表名.frm`，不论表采用哪种存储引擎，每张表都会有一个以`.frm`为后缀名的文件，这个文件记录了该表的表结构定义。这个`.frm`文件是以二进制格式存储的，直接打开会乱码。
- `user.ibd`：表空间文件，格式为 `表名.ibd`



### 五级结构

![image-20231218184304140](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218184304140.png)

InnoDB中的存储结构分为 5 级：表空间、段、区、页、行。

其中行就是我们要保存的每一列数据，页是InnoDB管理数据库的最小单位，即以页作为磁盘和内存的基本单位，一个页中存储了多行记录。

而其他的区、段均为是在页的基础上，为了更好地管理页而提出的概念。

从页开始，自底向上理解存储结构。

#### 行

一条完整的记录其实可以被分为`记录的额外信息`和`记录的真实数据`两大部分，额外信息又分为3类，分别是`变长字段长度列表`、`NULL值列表`和`记录头信息`

![image-20231218193033090](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218193033090.png)

首先定义一个表，初始化一些数据

```
mysql> CREATE TABLE record_format_demo (
    ->     c1 VARCHAR(10),
    ->     c2 VARCHAR(10) NOT NULL,
    ->     c3 CHAR(10),
    ->     c4 VARCHAR(10)
    -> ) CHARSET=ascii ROW_FORMAT=COMPACT;
Query OK, 0 rows affected (0.03 sec)

mysql> INSERT INTO record_format_demo(c1, c2, c3, c4) VALUES('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);
Query OK, 2 rows affected (0.02 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> SELECT * FROM record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
2 rows in set (0.00 sec)
```

##### 每个数据行的存储方式 - 变长字段列表

前边说过`MySQL`支持一些变长的数据类型，比如`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型，各种`BLOB`类型，这些变长的数据类型占用的存储空间分为两部分：

1. 真正的数据内容
2. 占用的字节数

因为如果不保存真实数据占用的字节数的话，MySQL服务器也不知道我们存储的数据究竟有多长。在`Compact`行格式中，把所有变长类型的列的长度都存放在记录的开头部位形成一个列表，按照列的顺序逆序存放，我们再次强调一遍，是逆序存放！我们拿`record_format_demo`表中的第一条记录来举个例子。因为`record_format_demo`表的`c1`、`c2`、`c4`列都是`VARCHAR(10)`类型的，也就是变长的数据类型，所以这三个列的值的长度都需要保存在记录开头处，因为`record_format_demo`表中的各个列都使用的是`ascii`字符集，所以每个字符只需要1个字节来进行编码，来看一下第一条记录各列内容的长度：

| 列名 | 存储内容 | 内容长度（十进制表示） | 内容长度（十六进制表示） |
| ---- | -------- | ---------------------- | ------------------------ |
| `c1` | `'aaaa'` | `4`                    | `0x04`                   |
| `c2` | `'bbb'`  | `3`                    | `0x03`                   |
| `c4` | `'d'`    | `1`                    | `0x01`                   |

又因为这些长度值需要按照列的逆序存放，所以最后`变长字段长度列表`的字节串用十六进制表示的效果就是（各个字节之间实际上没有空格，用空格隔开只是方便理解）：

```
01 03 04 
```

把这个字节串组成的`变长字段长度列表`填入上边的示意图中的效果就是：

[![1.3.16.变长字段长度列表1](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.16.%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A81.png)](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.3.16.变长字段长度列表1.png)

由于第一行记录中`c1`、`c2`、`c4`列中的字符串都比较短，也就是说内容占用的字节数比较小，用1个字节就可以表示，但是如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。具体用1个还是2个字节来表示真实数据占用的字节数，`MySQL`有它的一套规则，因为用汉字描述很长的概念很容易变得啰嗦从而让人迷惑，所以我们用公式来表示一下，首先声明一下`W`、`M`和`L`的意思：

1. 假设某个字符集中表示一个字符最多需要使用的字节数为`W`，也就是使用`SHOW CHARSET`语句的结果中的`Maxlen`列，比方说`utf8`字符集中的`W`就是`3`，`gbk`字符集中的`W`就是`2`，`ascii`字符集中的`W`就是`1`。
2. 对于变长类型`VARCHAR(M)`来说，这种类型表示能存储最多`M`个字符，所以这个类型能表示的字符串最多占用的字节数就是`M×W`，
3. 假设它存储的字符串占用的字节数是`L`。

所以确定使用1个字节还是2个字节表示真正字符串占用的字节数的规则就是这样：

- 如果`M×W < 256`，那么使用1个字节来表示真正字符串占用的字节数。
- 如果`M×W >= 256`，则分为两种情况：
- - 如果`L < 128`，则用1个字节来表示真正字符串占用的字节数
  - 如果`L >= 128`，则用2个字节来表示真正字符串占用的字节数

> 也就是说确定使用1个字节还是2个字节来表示真实数据占用的字节数取决于`W`、`M`和`L`的值，上边的`c1`、`c2`、`c3`列的`W=1`，`M=10`，所以符合`M×W < 256`，所以使用1字节来表示真正字符串占用的字节数。

需要注意的一点是，变长字段长度列表中只存储值为 ***非NULL*** 的列内容占用的长度，值为 ***NULL*** 的列的长度是不储存的 。也就是说对于第二条记录来说，因为`c4`列的值为`NULL`，所以`变长字段长度列表`只需要存储`c1`和`c2`列的长度即可。其中`c1`列存储的值为`'eeee'`，占用的字节数为`4`，`c2`列存储的值为`'fff'`，占用的字节数为`3`，所以`变长字段长度列表`需2个字节。填充完`变长字段长度列表`的两条记录的对比图如下：

![image-20231218193403617](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218193403617.png)

##### 每个数据行的存储方式 - NULL值列表

表中的某些列可能存储`NULL`值，如果把这些NULL值都放到`记录的真实数据`中存储会很占地方，所以`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中，它的处理过程是这样的：

1. 首先统计表中允许存储`NULL`的列有哪些。

   前边说过，主键列、被`NOT NULL`修饰的列都是不可以存储`NULL`值的，所以在统计的时候不会把这些列算进去。比方说表`record_format_demo`的3个列`c1`、`c3`、`c4`都是允许存储`NULL`值的，而`c2`列是被`NOT NULL`修饰，不允许存储`NULL`值。

2. 如果表中没有允许存储 ***NULL*** 的列，则 *NULL值列表* 也不存在了，否则将每个允许存储`NULL`的列对应一个二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下：

   因为表`record_format_demo`有3个值允许为`NULL`的列，所以这3个列和二进制位的对应关系就是这样：

   ![image-20231218193518880](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218193518880.png)

   再一次强调，二进制位按照列的顺序逆序排列，所以第一个列`c1`和最后一个二进制位对应。

   - 二进制位的值为`1`时，代表该列的值为`NULL`。
   - 二进制位的值为`0`时，代表该列的值不为`NULL`。

3. `MySQL`规定`NULL值列表`必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补`0`。

   表`record_format_demo`只有3个允许为`NULL`的列，对应3个二进制位，不足一个字节，所以在字节的高位补`0`，效果就是这样：

   ![image-20231218193541797](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218193541797.png)

   知道了规则之后，再返回头看表`record_format_demo`中的两条记录中的`NULL值列表`应该怎么储存。因为只有`c1`、`c3`、`c4`这3个列允许存储`NULL`值，所以所有记录的`NULL值列表`只需要一个字节。

- 对于第一条记录来说，`c1`、`c3`、`c4`这3个列的值都不为`NULL`，所以它们对应的二进制位都是`0`，画个图就是这样：

  ![image-20231218193612961](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218193612961.png)

  所以第一条记录的`NULL值列表`用十六进制表示就是：`0x00`。

- 对于第二条记录来说，`c1`、`c3`、`c4`这3个列中`c3`和`c4`的值都为`NULL`，所以这3个列对应的二进制位的情况就是：

  ![image-20231218193645068](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218193645068.png)

  所以第一条记录的`NULL值列表`用十六进制表示就是：`0x06`。

所以这两条记录在填充了`NULL值列表`后的示意图就是这样：

![image-20231218193658120](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218193658120.png)

##### 每个数据行的存储方式 - 记录头

首先，创建一个新表：

```sql
mysql> CREATE TABLE page_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 VARCHAR(10000),
    ->     PRIMARY KEY (c1)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.03 sec)
```

如上所示，表中有三列，c1和c2用来存储整数的，c3用来存储字符串的。因为指定了主键为c1，所以MySQL就不会去创建那个隐藏的 row_id 列。指定了`ascii`字符集以及`Compact`的行格式，所以里面的每一条记录的行格式如下：

[![1.3.03.innodb中数据的行格式](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.03.InnoDB%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%8C%E6%A0%BC%E5%BC%8F.jpg)](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.3.03.InnoDB中数据的行格式.jpg)

先看一下行格式中每个属性代表的意思：

| 名称         | 大小（单位：bit） | 描述                                                         |
| ------------ | ----------------- | ------------------------------------------------------------ |
| 预留位1      | 1                 | 没有使用                                                     |
| 预留位2      | 1                 | 没有使用                                                     |
| delete_mask  | 1                 | 标记该记录是否被删除                                         |
| min_rec_mask | 1                 | 标记该记录是否为B+树的非叶子节点中的最小记录（索引时用到）   |
| n_owned      | 4                 | 表示当前槽管理的记录数                                       |
| heap_no      | 13                | 表示当前记录在记录堆(当前页)的位置信息                       |
| record_type  | 3                 | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录 |
| next_record  | 16                | 表示下一条记录的相对位置                                     |

由于这里只是描述在`User Records`中记录头的作用，所以下面只会说明一些相关的属性以及`c1`、`c2`、`c3`列的信息（其他信息没画不代表它们不存在，只是为了理解上的方便省略了～），简化后的行格式示意图就是这样： [![1.3.04.page_demo表简化行格式图](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.04.page_demo%E8%A1%A8%E7%AE%80%E5%8C%96%E8%A1%8C%E6%A0%BC%E5%BC%8F%E5%9B%BE.jpg)](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.3.04.page_demo表简化行格式图.jpg)

往表中插入几条数据：

```
mysql> INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

下面看看几条记录在页中的`User Records`是以何种形式进行体现的，为了方便理解，下面的图中把记录中的头信息和实际的数据都用的十进制进行的表示（其实都是二进制）：

[![1.3.05.插入4条记录后User Records](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.05.%E6%8F%92%E5%85%A54%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8EUser%20Records.jpg)](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.3.05.插入4条记录后User Records.jpg)

下面说说，记录头中的各个部分代表的含义：

###### delete_mask

这个属性说的是当前这条记录是否被删除，当值为0的时候代表着没有被删除，为1的时候标志着被删除了。

是的，您没看错，当您执行删除一个记录的操作的时候，被删除的记录还存在页中，您对它进行了删除，它会把的

记录头中的这个属性设置为1，只是打了个标记。

> 这些被删除的记录之所以不立即从磁盘上移除，是因为移除它们之后把其他的记录在磁盘上重新排列需要性能消耗，所以只是打个删除标记而已，而且这部分存储空间之后还可以重用，也就是说之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。
>
> 如果想彻底的从磁盘上移除这些被删除的记录，可以使用这个语句：
>
> ```
> optimize table '表名';
> ```
>
> 执行这个命令后服务器会重新规划表中记录的存储方式，把被标记为删除的记录从磁盘上移除。

###### min_rec_mask

有关索引的，记录索引的最小值，当遇到min()函数可直接获取

###### n_owned

记录组中，记录的数量

###### heap_no

这个属性是表示的当前记录在当前页中的位置，上面的一张图如果您仔细看了的话，会发现它们的位置分别是2、3、4、5，那么问题来了？ 0和1呢？

这是因为在每次创建的一页里面会自动的加入两条记录，这被称为`伪记录` 或者 `虚拟记录` （因为不是我们自己插入的）;

这两条伪记录一个代表着`最小记录`，一个代表着`最大记录` ；

记录大小的比较是通过主键值来比较的。在上面我们插入的几条记录中的从小到大的顺序就是：1 < 2 < 3 < 4,

这标志着这4条记录的大小依次递增。

不管我们插入了什么数据，页中的`最小记录` 和 `最大记录` 都是页生成时候的那两条伪记录。这两条伪记录的结构页相对简单，如下：

[![1.3.06.伪记录的行结构](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.06.%E4%BC%AA%E8%AE%B0%E5%BD%95%E7%9A%84%E8%A1%8C%E7%BB%93%E6%9E%84.jpg)](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.3.06.伪记录的行结构.jpg)

还记得页结构组成的七部分中一个部分叫`Infimum + SupreMum` ，这个部分用来存储最小记录和最大记录的，没错，就是这两条伪记录。

> 原因：由于这两条记录不是我们自己定义的记录，所以它们并不存放在`页`的`User Records`部分，他们被单独放在一个称为`Infimum + Supremum`的部分

[![1.3.07.伪记录与真实记录](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.07%E4%BC%AA%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%9C%9F%E5%AE%9E%E8%AE%B0%E5%BD%95.jpg)](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.3.07伪记录与真实记录.jpg)

由上面的图可以看出，最小记录和最大记录的heap_no的值分别为0和1，也就是说它们的位置最靠前。

###### record_type

这个属性表示当前记录的类型，一共有4种类型的记录，`0`表示普通记录，`1`表示B+树非叶节点记录，`2`表示最小记录，`3`表示最大记录。从图中我们也可以看出来，我们自己插入的记录就是普通记录，它们的`record_type`值都是`0`，而最小记录和最大记录的`record_type`值分别为`2`和`3` ，关于1暂且不说；

###### next_record

这个属性表示这从当前记录真实数据到下一条记录的真实数据的地址偏移量 ；

假如有一条记录的`next_record` 的值为12，就标志着从这条记录的真实数据的地址往后找12个字节就是下一条记录的真实数据（链表）。也就是说页中的数据之间的联系是一个**根据大小**比较后从小指到大的**单向链表**。

规定 **最小记录** 的下一条记录就本页中主键值最小的记录，而本页中主键值最大的记录的下一条记录就是 **最大记录**(最大的那条伪记录) ，为了更形象的表示一下这个`next_record`起到的作用，我们用箭头来替代一下`next_record`中的地址偏移量：

[![1.3.08.伪记录与真实记录-next record](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.08.%E4%BC%AA%E8%AE%B0%E5%BD%95%E4%B8%8E%E7%9C%9F%E5%AE%9E%E8%AE%B0%E5%BD%95-next%20record.jpg)](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.3.08.伪记录与真实记录-next record.jpg)

从上面可以看出，`最大记录` 的 `next_record` 的值为0，代表着最大记录的下一条记录是不存在的，它也是链条中的最后一个节点。

当从页中删除一条数据后可以看看链表会发生那些变化：

```
mysql> DELETE FROM page_demo WHERE c1 = 2;
Query OK, 1 row affected (0.02 sec)
```

删掉第2条记录后的示意图就是：

[![1.3.09.删除第二条记录后的示意图](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.09.%E5%88%A0%E9%99%A4%E7%AC%AC%E4%BA%8C%E6%9D%A1%E8%AE%B0%E5%BD%95%E5%90%8E%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.3.09.删除第二条记录后的示意图.jpg)

从上面可以看到：

> 当我们删除第二条记录后，链表中的变化最明显的就是各个节点之间的联系，它会把被删除数据的上一条记录和被删除数据的下一条数据进行关联（这条数据还是存在的，之前说的那个删除标记别忘了哦）。
>
> - 第2条记录并没有从存储空间中移除，而是把该条记录的`delete_mask`值设置为`1`。
> - 第2条记录的`next_record`值变为了0，意味着该记录没有下一条记录了。
> - 第1条记录的`next_record`指向了第3条记录。
> - 还有一点您可能忽略了，就是`最大记录`的`n_owned`值从`5`变成了`4`，关于这一点的变化我们稍后会详细说明的。
>
> 所以得到：不论我们怎么对页中的记录做增删改操作，InnoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。

下面把删除的记录再次插入：

```
mysql> INSERT INTO page_demo VALUES(2, 200, 'bbbb');
Query OK, 1 row affected (0.00 sec)
```

来看看发生了什么变化：

[![1.3.10.重新插入第2条记录](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.10.%E9%87%8D%E6%96%B0%E6%8F%92%E5%85%A5%E7%AC%AC2%E6%9D%A1%E8%AE%B0%E5%BD%95.jpg)](https://github.com/asdbex1078/MySQL/blob/master/mysql-image/1.3.10.重新插入第2条记录.jpg)

很明显的可以看到，`InnoDB`并没有因为新记录的插入而为它申请新的存储空间，而是直接复用了原来被删除记录的存储空间。

##### 每个数据行的存储方式 - 真实数据

`记录的真实数据`除了我们插入的那些列的数据，`MySQL`会为每个记录默认的添加一些列（也称为`隐藏列`），具体的列如下：

| 列名             | 是否必须 | 占用空间 | 描述                   |
| ---------------- | -------- | -------- | ---------------------- |
| `row_id`         | 否       | `6`字节  | 行ID，唯一标识一条记录 |
| `transaction_id` | 是       | `6`字节  | 事务ID                 |
| `roll_pointer`   | 是       | `7`字节  | 回滚指针               |

需要注意的是，MySQL服务器会为每条记录都添加 ***transaction_id*** 和 ***roll_pointer*** 这两个列，但是 ***row_id*** 只有在表没有定义主键的时候才会为记录添加，相当于MySQL服务器帮我们来添加一个主键。这些列的值不用我们操心，`MySQL`服务器会自己帮我们添加的。

##### 特殊情况：行溢出

###### VARCHAR(M)

对于`VARCHAR(M)`类型的列最多可以占用`65535`个字节。其中的`M`代表该类型最多存储的字符数量，如果我们使用`ascii`字符集的话，一个字符就代表一个字节，我们看看`VARCHAR(65535)`是否可用：

```
mysql> CREATE TABLE varchar_size_demo(
    ->     c VARCHAR(65535)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
mysql>
```

从报错信息里可以看出，`MySQL`对一条记录占用的最大存储空间是有限制的，除了`BLOB`或者`TEXT`类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过`65535`个字节。所以`MySQL`服务器建议我们把存储类型改为`TEXT`或者`BLOB`的类型。这个`65535`个字节除了列本身的数据之外，还包括一些`storage overhead`，比如说我们为了存储一个`VARCHAR(M)`类型的列，需要占用3部分存储空间：

- 真实数据
- 真实数据占用字节的长度
- `NULL`值标识，如果该列有`NOT NULL`属性则可以没有这部分存储空间

如果该`VARCHAR`类型的列没有`NOT NULL`属性，那最多只能存储`65532`个字节的数据，因为真实数据的长度需要占用2个字节，`NULL`值标识需要占用1个字节：

```
mysql> CREATE TABLE varchar_size_demo(
    ->      c VARCHAR(65532)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)
```

如果`VARCHAR`类型的列有`NOT NULL`属性，那最多只能存储`65533`个字节的数据，因为真实数据的长度需要占用2个字节，不需要`NULL`值标识：

```
mysql> DROP TABLE varchar_size_demo;
Query OK, 0 rows affected (0.01 sec)

mysql> CREATE TABLE varchar_size_demo(
    ->      c VARCHAR(65533) NOT NULL
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)
```

如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那会怎么样呢？来看一下：

```sql
mysql> DROP TABLE varchar_size_demo;
Query OK, 0 rows affected (0.00 sec)
mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=gbk ROW_FORMAT=Compact;
ERROR 1074 (42000): Column length too big for column 'c' (max = 32767); use BLOB or TEXT instead

mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=utf8 ROW_FORMAT=Compact;
ERROR 1074 (42000): Column length too big for column 'c' (max = 21845); use BLOB or TEXT instead
```

从执行结果中可以看出，如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那`M`的最大取值取决于该字符集表示一个字符最多需要的字节数。比方说`gbk`字符集表示一个字符最多需要`2`个字节，那在该字符集下，`M`的最大取值就是`32767`，也就是说最多能存储`32767`个字符；`utf8`字符集表示一个字符最多需要`3`个字节，那在该字符集下，`M`的最大取值就是`21845`，也就是说最多能存储`21845`个字符。

###### 记录中的数据太多产生的溢出

以`ascii`字符集下的`varchar_size_demo`表为例，插入一条记录：

```
mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.01 sec)

mysql> INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));
Query OK, 1 row affected (0.00 sec)
```

其中的`REPEAT('a', 65532)`是一个函数调用，它表示生成一个把字符`'a'`重复`65532`次的字符串。前边说过，`MySQL`中磁盘和内存交互的基本单位是`页`，也就是说`MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节，而一个`VARCHAR(M)`类型的列就最多可以存储`65532`个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。

在`Compact`和`Reduntant`行格式中，对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据，把剩余的数据分散存储在几个连续的页中，只在`记录的真实数据`处用20个字节存储指向这些页的地址，从而可以找到剩余数据所在的页，如图所示：

![image-20231218194206689](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218194206689.png)

从图中可以看出来，对于`Compact`和`Reduntant`行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前`786`个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做`行溢出`。画一个简图就是这样：

![image-20231218194215602](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218194215602.png)

不只是 ***VARCHAR(M)*** 类型的列，其他的 ***TEXT***、***BLOB*** 类型的列在存储数据非常多的时候也会发生`行溢出`。

> 关于 Dynamic参考[这里](https://github.com/zhangyachen/zhangyachen.github.io/issues/96)

###### 行溢出临界点

那发生`行溢出`的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生`行溢出`？

`MySQL`中规定一个页中至少存放两行记录，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以我们以上边的`varchar_size_demo`表为例，它只有一个列`c`，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会`行溢出`的现象呢？这得分析一下页中的空间都是如何利用的。

- 每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要`136`个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。

- 每个记录需要的额外信息是`27`字节。

  这27个字节包括下边这些部分：

  - 2个字节用于存储真实数据的长度
  - 1个字节用于存储列是否是NULL值
  - 5个字节大小的头信息
  - 6个字节的`row_id`列
  - 6个字节的`transaction_id`列
  - 7个字节的`roll_pointer`列

假设一个列中存储的数据字节数为n，那么发生`行溢出`现象时需要满足这个式子：

```
136 + 2×(27 + n) > 16384
```

求解这个式子得出的解是：`n > 8098`。也就是说如果一个列中存储的数据不大于`8098`个字节，那就不会发生`行溢出`，否则就会发生`行溢出`。

这个只是针对只有一个列的`varchar_size_demo`表来说的，如果表中有多个列，那上边的式子又得改一改了，所以重点就是：你不用关注这个临界点是什么，只要知道如果我们想一个行中存储了很大的数据时，可能发生`行溢出`的现象。

#### 页

在数据库中，IO操作的最小单位是页，也就是说无论读一行还是读多行，都会把这些行所在的页都读取到内存中，一次至少读取或者刷新页大小的数据内容。

##### 为什么要把页作为基本单位

记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。

而且，根据

##### 页的组织结构

![img](MySQL%E5%9F%BA%E7%A1%80.assets/1496926-20201126113029931-1621355504.png)

数据页由 7 个部分组成：

| 名称               | 中文名             | 占用空间大小 | 简单描述                                  |
| ------------------ | ------------------ | ------------ | ----------------------------------------- |
| File Header        | 文件头             | 38字节       | 描述页的信息                              |
| Page Header        | 页头               | 56字节       | 页的状态信息                              |
| Infimum + SupreMum | 最小记录和最大记录 | 26字节       | 两个虚拟的行记录（后面会说明）            |
| User Records       | 用户记录           | 不确定       | 实际存储的行记录内容                      |
| Free Space         | 空闲空间           | 不确定       | 页中尚未使用的空间                        |
| Page Directory     | 页目录             | 不确定       | 存放着数据页组，形成的slot， 记录相对位置 |
| File Trailer       | 文件结尾           | 8字节        | 结尾信息                                  |

###### FileHeader

`File Header`描述的就是`页`外的各种状态信息，比方说这个页的编号是多少，它的上一个页、下一个页是谁啦。

`File Header`是`InnoDB`页的第一部分，这个部分占用固定的`38`个字节。

| 名称                             | 大小（单位：byte） | 描述                                                         |
| -------------------------------- | ------------------ | ------------------------------------------------------------ |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4                  | 页的校验和（checksum值）                                     |
| FIL_PAGE_OFFSET                  | 4                  | 页号                                                         |
| FIL_PAGE_PREV                    | 4                  | 上一个页的页号                                               |
| FIL_PAGE_NEXT                    | 4                  | 下一个页的页号                                               |
| FIL_PAGE_LSN                     | 8                  | 最后被修改的日志序列位置（英文名是：Log Sequence Number）    |
| FIL_PAGE_TYPE                    | 2                  | 该页的类型：B+树叶子节点、Undo log页、索引非叶子节点页、Insert Buffer空闲列表、Insert Buffer BitMap、系统页、扩展描述页、BLOB页 |
| FIL_PAGE_FILE_FLUSH_LSN          | 8                  | 仅在系统表空间的一个页中定义，代表文件至少被更新到了该LSN值，独立表空间中都是0 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4                  | 页属于哪个表空间                                             |

- `FIL_PAGE_SPACE_OR_CHKSUM`

  代表当前页面的校验和（checksum）。

- `FIL_PAGE_OFFSET`

  每一个`页`都有一个单独的页号，`InnoDB`通过页号来可以唯一定位一个`页`。

- `FIL_PAGE_TYPE`

  这个代表当前`页`的类型，InnoDB为了不同的目的而把页分为不同的类型。

- `FIL_PAGE_PREV`和`FIL_PAGE_NEXT`

  一张表中可以有成千上万条记录，一个页只有`16KB`，所以可能需要好多页来存放据，`FIL_PAGE_PREV`和`FIL_PAGE_NEXT`就分别代表本页的上一个和下一个页的页号（双向链表）。

###### 插入数据过程

在存储数据的时候，记录会存储到`User Records`部分 。

在一个页新形成的时候是不存在`User Records` 这个部分的，每当我们在插入一条记录的时候，都会从Free Space中去申请一块大小符合该记录大小的空间并划分到`User Records`

![1.3.02.记录插入页的过程](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.02.%E8%AE%B0%E5%BD%95%E6%8F%92%E5%85%A5%E9%A1%B5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg)

当`Free Space`的部分空间全部被`User Records`部分替换掉之后，就意味着当前页使用完毕，如果还有新的记录插入，需要再去申请新的页，和该页以双向链表关联。

###### 页内的组织

InnoDB会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个槽，存放在`Page Directory`中，便于二分查找定位数据。

![1.3.13.page directory 详细分组示意图](MySQL%E5%9F%BA%E7%A1%80.assets/1.3.13.page%20directory%20%E8%AF%A6%E7%BB%86%E5%88%86%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

上图中，只保留了头信息中的`n_owned`和`next_record`属性，也省略了各个记录之间的箭头，没画不等于没有！

因为各个槽代表的记录的主键值都是从小到大排序的，所以可以使用`二分法`来进行快速查找。4个槽的编号分别是：`0`、`1`、`2`、`3`、`4`，所以初始情况下最低的槽就是`low=0`，最高的槽就是`high=4`。

例如想找主键值为`5`的记录，查找步骤为：

1. 首先得到中间槽的位置：`(0 + 4)/2 = 2` ,所以得到槽2，根据槽2的地址偏移量知道它的主键值是8，因为8>5，设置`high=2` ，`low`不变；
2. 再次计算中间槽的位置：`(0 + 2)/2 = 1` ,所以得到槽1，根据槽1的地址偏移量知道它的主键值是4, 因为4<5，设置`low=1` ，`high`不变；
3. 因为`high - low`的值为1，所以确定主键值为`5`的记录在槽1和槽2之间，接下来就是遍历链表的查找了；

> 在一个数据页中查找指定主键值的记录的过程分为两步：
>
> 1. 通过二分法确定该记录所在的槽。
> 2. 通过记录的next_record属性组成的链表遍历查找该槽中的各个记录。


###### 页与页之间的组织

页A、页B、....页N并不要求在物理上相连，只需要通过双向链表管理即可。

这样要依赖于 File Header 中的两个属性

- FIL_PAGE_PREV：上一个页的页号
- FIL_PAGE_NEX：下一个页的页号

![image-20231218192431024](MySQL%E5%9F%BA%E7%A1%80.assets/image-20231218192431024.png)

##### 页大小

###### 修改页大小

页是InnoDB存储引擎磁盘管理的最小单位，每个页默认16KB。

InnoDB存储引擎从1.2.x版本开始，可以通过参数`innodb_page_size`将页的大小设置为4K、8K、16K。

在MySQL中，更改数据页的大小涉及到重新创建数据库的过程，因为数据页大小是在数据库创建时确定的，并且不能直接更改。

以下是一般的步骤：

- 备份数据库：在进行任何结构更改之前，强烈建议备份数据库以防止数据丢失。

- 停止MySQL服务：使用适当的方法停止MySQL数据库服务，确保数据库处于离线状态。

- 修改配置文件：找到MySQL的配置文件（例如my.cnf或my.ini），在该文件中找到[mysqld]部分，并添加或修改以下参数：

  ```
  innodb_page_size = <新的数据页大小>
  ```

> 请注意，<新的数据页大小>应替换为您想要设置的新的数据页大小，以字节为单位（例如4KB、8KB、16KB等）。请确保选择的数据页大小是MySQL版本和操作系统支持的，否则可能会导致问题。

 - 删除旧的数据文件：在MySQL数据目录中找到包含您要更改数据页大小的数据库的子目录。删除该子目录中的所有文件（除了ibdata1和ib_logfile*文件）。
- 重新创建数据库：使用MySQL的初始化工具重新创建数据库。这将根据新的数据页大小创建新的数据文件。
- 启动MySQL服务：使用适当的方法启动MySQL数据库服务


###### 页大小的影响 //to fix未校验

- 对行记录数量的影响

对于 4KB、8KB、16KB 和 32KB 的页大小，最大行大小 (不包括存储在页外的任何可变长度的列) 略小于页大小的一半。例如，默认 innodb_page_size 为 16KB 的最大行大小约为 8000 字节。然而，对于 InnoDB 页面大小为 64KB 的页面，最大行大小大约是 16000 字节。LONGBLOB 和 LONGTEXT 列必须小于 4GB，包括 BLOB 和文本列在内的总行大小必须小于 4GB。

- 对索引的影响：

如果在创建 MySQL 实例时通过指定 innodb_page_size 选项将 InnoDB 页面大小减少到 8KB 或 4KB，索引键的最大长度将按比例降低，这是基于 16KB 页面大小的 3072 字节限制。也就是说，当页面大小为 8KB 时，最大索引键长度为 1536 字节，而当页面大小为 4KB 时，最大索引键长度为 768 字节。

- 不同的 Page 大小，表空间限制
- 对字段的影响

对于 4KB、8KB、16KB 和 32KB 的 innodb_page_size 设置，最大行长度略小于数据库页的一半。例如，对于默认的 16KB InnoDB 页面大小，最大行长度略小于 8KB。对于 64KB 的页面，最大行长度略小于 16KB。 如果一行不超过最大行长度，则所有行都存储在本地页中。如果一行超过最大行长，则选择可变长度列用于外部页外存储，直到该行符合最大行长限制为止。

- COMPACTRow Formats：

当一个可变长度的列被选择用于外部页外存储时，InnoDB 将前 768 个字节本地存储在行中，其余的存储在外部溢出的页面中。每个这样的列都有自己的溢出页列表。768 字节的前缀伴有一个 20 字节的值，该值存储列的真实长度，并指向存储其余值的溢出列表

- DYNAMICRow Formats：

当一个可变长度的列被选择用于外部页外存储时，InnoDB 在本地的行中存储一个 20 字节的指针，其余的则在外部存储到溢出的页面中，LONGBLOB 和 LONGTEXT 列必须小于 4GB，包括 BLOB 和 TEXT 列在内的总行长度必须小于 4GB。

#### 表空间

表空间可以看做是InnoDB存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。在默认情况下InnoDB存储引擎有一个共享表空间`ibdata1`，所有数据都存放在这个表空间内。

如果启用了参数`innodb_file_per_table`，则每张表内的数据可以单独放到一个表空间内。需要注意的是，这些单独的表空间文件仅存储该表的数据、索引和插入缓冲Bitmap等信息，其余信息还是存放在共享表空间中，例如 undo日志、插入缓冲索引页、系统事务信息、二次写缓冲等。

因此即使在启用了参数`innodb_file_per_table`之后，共享表空间的大小还是会不断地增加，例如事务中写入了undo日志，就算回滚了，共享表空间的大小也不会缩小。但是会判断这些undo信息是否还需要，不需要的话，就会将这些空间标记为可用空间，供下次重复使用。

#### 段



#### 簇







#### 行



## 索引

索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是**索引是数据的目**

![img](MySQL%E5%9F%BA%E7%A1%80.assets/%E7%B4%A2%E5%BC%95%E6%8F%90%E7%BA%B2.png)

### 索引分类

按照四个角度来分类索引。

- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

#### 物理存储角度

##### 聚集索引\非聚集索引

聚集索引是一种对磁盘实际数据重新组织并排序的索引结构，它的索引页面指向实际的数据页面，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里，规定了数据在表中的物理存储顺序。

非聚集索引指定了表中数据的逻辑顺序，索引的叶子层并不与实际的数据页相重叠，而是记录了主键值，指向主键值的是聚集索引字段的值。

![回表](MySQL%E5%9F%BA%E7%A1%80.assets/%E5%9B%9E%E8%A1%A8.drawio.png)

> [!note]两者区别：
>
> 1. 聚集索引只能有一个，非聚集索引可以有多个 
> 2. 聚集索引是在物理上连续，实际数据按照聚集索引排序；非聚集索引只是逻辑上连续，物理上并不连续
> 3. 聚集索引查询速度比非聚集索引快，但是数据更新速度慢
> 4. 聚集索引的叶节点是实际的数据节点；而非聚集索引的叶节点是一个指向记录数据的索引指针

InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；

其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。**创建的主键索引和二级索引默认使用的是 B+Tree 索引**。

##### 回表

在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。

> 比如下面这条查询语句：
>
> ```sql
> select id from product where product_no = '0002';
> ```
>
> 查询的字段在【 主键、建立聚合索引的字段 】集合之中，可以直接返回。

如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。

####  从数据结构角度

每一种存储引擎支持的索引类型不一定相同，表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型：

![img](MySQL%E5%9F%BA%E7%A1%80.assets/%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB.drawio.png)

##### ❗️B+索引

###### B+树

B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。

![B+树索引](MySQL%E5%9F%BA%E7%A1%80.assets/mysql-0a47bec7-1cf2-47d7-94e2-3cd82ce806c7.jpg)

有两个重点：

- 最外面的方块，称为一个磁盘块，可以看到每个磁盘块包含几个数据项（粉色所示）和指针（蓝色所示），如根节点磁盘包含数据项 17 和 35，包含指针 P1、P2、P3，P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。

  真实的数据存在于叶子节点即 3、4、5……、65。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中。

- 叶子节点之间使用双向指针连接，最底层的叶子节点形成了一个双向有序链表，可以进行范围查询。

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找，直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。

插入删除操作记录会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。

###### B+树存储数据条数

> [!note]
>
> 在InnoDB中，B+树每一个节点可以引出多少路节点是有限制的：
>
> 一方面受限于InnoDB中的页大小，非叶节点的大小限制为一个页，默认16k；
>
> 一方面受限于索引字段类型的长度，非叶节点存储的数据包括字段类型和指针，因此每存储一个单位需要占据(键值+指针)的大小。

![B+树存储数据条数](MySQL%E5%9F%BA%E7%A1%80.assets/mysql-16f3523d-20b0-4376-908d-ac40b329768f.jpg)

假设索引字段是 bigint 类型，长度为 8 字节。指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节。非叶子节点(一页)可以存储 16384/14=1170 个这样的 单元(键值+指针)，代表有 1170 个指针。

树深度为 2 的时候，有 1170^2 个叶子节点，可以存储的数据为 1170*1170*16=**21902400**。

在查找数据时一次页的查找代表一次 IO，也就是说，一张 2000 万左右的表，查询数据最多需要访问 3 次磁盘。

所以在 InnoDB 中 B+ 树深度一般为 1-3 层，它就能满足千万级的数据存储。

> [!ATTENTION] 
>
> 思考这个问题，为什么限制索引中的一个节点的大小为一个页，如果超过大小后页分裂，用双向链表连接起来又怎么样呢？
>
> 其实原则是可以实现的，限制节点大小是基于性能的考虑。
>
> 如果索引的节点用多个页，使用双向链表连接的话，索引节点为了查到对应的值需要：
>
> - 通过树结构找到对应的下级索引页区域
> - 在索引页间横向遍历
> - 在索引页内二分查找
>
> 无疑增加了性能损耗，因此在InnoDB设计中，用竖向的多层树结构，来避免索引目录页间的横向遍历，把页间查找的次数压缩为树的层数，故限制索引中的一个节点的大小为一个页。
>
> 同时，Innodb规定一个页至少容纳2条记录，这样做是为了控制树的高度，不让B+树的性能优势丧失。

###### B+索引

因为不再需要进行全表扫描，只需要对树进行搜索即可，因此查找速度快很多。除了用于查找，还可以用于排序和分组。

 B+Tree 索引分为主索引和辅助索引，即上文中说过的：

- 主索引的叶子节点 data 域记录着完整的数据记录
- 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找

###### B+Tree vs B Tree

B树的结构：

![这里写图片描述](MySQL%E5%9F%BA%E7%A1%80.assets/lo6pyx99bc.png)

B+树和B树的区别是：

1. B树的节点(根节点/父节点/中间节点/叶子节点)中没有重复元素，B+树有。
2. B树的中间节点会存储数据指针信息，而B+树只有叶子节点才存储。
3. B+树的每个叶子节点有一个指针指向下一个节点，把所有的叶子节点串在了一起。

那B+树比起B树的优点：

1. 由于中间节点不存指针，同样大小的磁盘页可以容纳更多的节点元素，树的高度就小。（数据量相同的情况下，B+树比B树更加“矮胖”），查找起来就更快。
2. B+树每次查找都必须到叶子节点才能获取数据，而B树不一定，B树可以在非叶子节点上获取数据。因此B+树查找的时间更稳定。
3. B+树的每一个叶子节点都有指向下一个叶子节点的指针，方便范围查询和全表查询：只需要从第一个叶子节点开始顺着指针一直扫描下去即可，适合 MySQL 中常见的基于范围的顺序查找，而B树则要对树做中序遍历。

###### B+Tree vs 二叉树

对于有 N 个叶子节点的 B+Tree，其搜索复杂度为`O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。

在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。

而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 `O(logN)`，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。

###### B+Tree vs Hash

Hash 在做等值查询的时候效率快，复杂度为 O(1)。

但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。

##### 哈希索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制:

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

##### 全文索引

MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。

全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。

InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

##### 空间数据索引

这是一种比较特殊的索引，MyISAM 存储引擎支持空间数据索引(R-Tree)，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

#### 字段特性角度

从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引：

- 主键索引：建立在主键字段上的索引。
- 唯一索引：索引值必须唯一，可以允许有空值。
- 普通索引：既不要求字段为主键，也不要求字段唯一。
- 前缀索引：对字符类型字段的前几个字符建立的索引。

##### 主键索引

主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。

在创建表时，创建主键索引的方式如下：

```sql
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```

##### 唯一索引

唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。

在创建表时，创建唯一索引的方式如下：

```sql
CREATE TABLE table_name  (
  ....
  UNIQUE KEY(index_column_1,index_column_2,...) 
);
```

建表后，如果要创建唯一索引，可以使用这面这条命令：

```sql
CREATE UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

##### 普通索引

普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

在创建表时，创建普通索引的方式如下：

```sql
CREATE TABLE table_name  (
  ....
  INDEX(index_column_1,index_column_2,...) 
);
```

建表后，如果要创建普通索引，可以使用这面这条命令：

```sql
CREATE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```

##### 前缀索引

前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。

使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。

在创建表时，创建前缀索引的方式如下：

```sql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 
```

建表后，如果要创建前缀索引，可以使用这面这条命令：

```sql
CREATE INDEX index_name
ON table_name(column_name(length)); 
```

#### 字段个数角度

字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。

- 建立在单列上的索引称为单列索引，比如主键索引；
- 建立在多列上的索引称为联合索引；

##### 单列索引

建立在单列上的索引称为单列索引，不再赘述。

##### 联合索引

###### 最左匹配原则

通过将多个字段组合成一个索引，该索引就被称为联合索引。

例如，将商品表中的 product_no 和 name 字段组合成联合索引`(product_no, name)`，创建联合索引的方式如下：

```sql
CREATE INDEX index_product_no_name ON product(product_no, name);
```

联合索引`(product_no, name)` 的 B+Tree 示意图如下：

![联合索引](MySQL%E5%9F%BA%E7%A1%80.assets/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.drawio.png)

**联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。**

当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。

因此，使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。

###### 联合索引失效

在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。

比如，如果创建了一个 `(a, b, c)` 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：

- where a=1；
- where a=1 and b=2 and c=3；
- where a=1 and b=2；

> 需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。
>
> 查询优化器会对SQL做优化，优化分为：1. 条件优化，2.计算全表扫描成本，3. 找出所有能用到的索引，4. 针对每个索引计算不同的访问方式的成本，5. 选出成本最小的索引以及访问方式，因此 a 字段在 where 子句的顺序并不重要。

但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:

- where b=2；
- where c=3；
- where b=2 and c=3；

上面这些查询条件之所以会失效，是因为`(a, b, c)` 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，**b 和 c 是全局无序，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。

###### 联合索引范围查询

联合索引有一些特殊情况，**并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询**，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。

这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。**也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引**。

> [!tip]
>
> **联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。**
>
> **注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，范围查询字段后面的字段还会用到联合索引**。

见下面的例子：

**例子1 Q1**

 `select * from t_table where a > 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a > 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 a > 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a > 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。

**但是在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的**。比如前面图的联合索引的 B+ Tree 里，下面这三条记录的 a 字段的值都符合 a > 1 查询条件，而 b 字段的值是无序的：

- a 字段值为 5 的记录，该记录的 b 字段值为 8；
- a 字段值为 6 的记录，该记录的 b 字段值为 10；
- a 字段值为 7 的记录，该记录的 b 字段值为 5；

因此，我们不能根据查询条件 b = 2 来进一步减少需要扫描的记录数量（b 字段无法利用联合索引进行索引查询的意思）。

所以在执行 Q1 这条查询语句的时候，对应的扫描区间是 (2, + ∞)，形成该扫描区间的边界条件是 a > 1，与 b = 2 无关。

因此，Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引。

**例子2 Q2**

 `select * from t_table where a >= 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

Q2 和 Q1 的查询语句很像，唯一的区别就是 a 字段的查询条件「大于等于」。

由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 >= 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 >= 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a>= 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。

虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，**但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的**（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。

于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b = 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 a = 1 and b = 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描。

所以，Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。

**例子3 Q3**

`SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？

Q3 查询条件中 `a BETWEEN 2 AND 8` 的意思是查询 a 字段的值在 2 和 8 之间的记录。不同的数据库对 BETWEEN ... AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 >= and =<。而有的数据库则不包含 value1 和 value2 边界值（类似于 > and <）。

由于 MySQL 的 BETWEEN 包含 value1 和 value2 边界值，所以类似于 Q2 查询语句，因此 Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。

**例子4 Q4**

`SELECT * FROM t_user WHERE name like 'j%' and age = 22`，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？

由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的， 于是在进行索引扫描的时候，可以定位到符合前缀为 ‘j’ 的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为 ‘j’ 为止。

所以 a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是['j','k')。注意， j 是闭区间。如下图：

![img](MySQL%E5%9F%BA%E7%A1%80.assets/q4-1.drawio.png)

虽然在符合前缀为 ‘j’ 的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，**但是对于符合 name = j 的二级索引记录的范围里，age字段的值是「有序」的**（因为对于联合索引，是先按照 name 字段的值排序，然后在 name 字段的值相同的情况下，再按照 age 字段的值进行排序）。

于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 name 字段值为 ‘j’ 时，可以通过 age = 22 条件减少需要扫描的二级索引记录范围（age 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 `name = 'j' and age = 22` 条件的第一条记录时开始扫描，而不需要从第一个 name 为 j 的记录开始扫描 。如下图的右边：

![img](MySQL%E5%9F%BA%E7%A1%80.assets/q4-2.drawio.png)

所以，Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询。

###### 索引下推

对于联合索引（a, b），在执行 `select * from table where a > 1 and b = 2` 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？

- 在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。

  ![没有使用 ICP](MySQL%E5%9F%BA%E7%A1%80.assets/mysql-c58f59e0-850b-4dfd-8129-2dfc51cf4768.jpg)

- 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， **可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**。

  ![使用 ICP](MySQL%E5%9F%BA%E7%A1%80.assets/mysql-a8525cf3-2d16-49a9-a7da-a19762ed16df.jpg)

当查询语句的执行计划里，出现了 Extra 为 `Using index condition`，那么说明使用了索引下推的优化。

###### 索引区分度

建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高。

**建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到**。

区分度就是某个字段 column 不同值的个数「除以」表的总行数，计算公式如下：

![区分度计算公式](MySQL%E5%9F%BA%E7%A1%80.assets/%E5%8C%BA%E5%88%86%E5%BA%A6.png)

比如，性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 UUID 这类字段就比较适合做索引或排在联合索引列的靠前的位置。

因为如果索引的区分度很小，假设字段的值分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是"30%"）很高的时候，它一般会忽略索引，进行全表扫描。

###### 联合索引应用场景-排序

针对针对下面这条 SQL，如何通过索引来提高查询效率呢？

```sql
select * from order where status = 1 order by create_time asc
```

普遍的回答是单独给 status 建立一个索引就可以了。

但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。

因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。

所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。

### 索引创建的时机

索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：

- 需要占用物理空间，数量越大，占用空间越大；
- 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；
- 会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。

所以，索引不是万能钥匙，它也是根据场景来使用的。

#### 适用索引的时机

- 字段有唯一性限制的，比如商品编码；
- 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。

#### 不需要索引的时机

- `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在大量重复数据，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。
- 表数据太少的时候，不需要创建索引；
- 经常更新的字段不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的

### 索引优化





## InnoDB日志总结 //todo

InnoDB引擎中有这三种日志：

- **undo log（回滚日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的**原子性**，主要**用于事务回滚和 MVCC**。
- **redo log（重做日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的**持久性**，主要**用于掉电等故障恢复**；
- **binlog （归档日志）**：是 Server 层生成的日志，主要**用于数据备份和主从复制**；





