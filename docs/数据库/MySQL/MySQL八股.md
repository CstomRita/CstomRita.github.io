@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>

## 基础篇

### BLOB和TEXT有什么区别？

BLOB 是一个二进制对象，可以容纳可变数量的数据。

TEXT 是一个不区分大小写的 BLOB。

BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。

### 

## 事务篇

###  事务还没提交的时候，redo log 能不能被持久化到磁盘？

事务还没有提交的时候，redo log 是有可能被持久化到磁盘的。

redolog 的具体落盘操作是这样的：在事务运行的过程中，MySQL 会先把日志写到 redolog buffer 中，等到事务真正提交的时候，再统一把 redolog buffer 中的数据写到 redolog 文件中。不过这个从 redolog buffer 写到 redolog 文件中的操作也就是 write 并不就是落盘操作了，这里仅仅是把 redolog 写到了文件系统的 page cache 上，最后还需要执行 fsync 才能够实现真正的落盘。

也就是说，redolog 其实存在三种状态：

1. 事务执行过程中，存在 MySQL 的进程内存中的 redolog buffer 中
2. 事务提交，执行 write 操作存在文件系统的 page cache 中，但是没有执行 fsync 操作持久化到磁盘
3. 事务提交，执行 fsync 操作持久化到磁盘

relog的刷盘时机有三种情况：

第一种情况：InnoDB 有一个后台线程，每隔 1 秒轮询一次，具体的操作是这样的：调用 write 将 redolog buffer 中的日志写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。而在事务执行中间过程的 redolog 都是直接写在 redolog buffer 中的，也就是说，一个没有提交的事务的 redolog，也是有可能会被后台线程一起持久化到磁盘的。

第二种情况：innodb_flush_log_at_trx_commit 设置是 1时，每次事务提交的时候，都执行 fsync 将 redolog 直接持久化到磁盘，假设事务 A 执行到一半，已经写了一些 redolog 到 redolog buffer 中，这时候有另外一个事务 B 提交，事务 B 要把 redolog buffer 里的日志全部持久化到磁盘，这时候，就会带上事务 A 在 redolog buffer 里的日志一起持久化到磁盘。

第三种情况：redo log buffer 占用的空间达到 redolo buffer 大小(由参数 innodb_log_buffer_size 控制，默认是 8MB)一半的时候，后台线程会主动写盘。不过由于这个事务并没有提交，所以这个写盘动作只是 write 到了文件系统的 page cache，仍然是在内存中，并没有调用 fsync ，此时并不会落盘。

### MVCC是什么？



### 说说MySQL中的锁？



### 都有哪些隔离级别，都会产生什么问题？



### MySQL是怎么实现这些隔离级别的？



### MySQL是如何实现持久化的？



### MySQL是如何保证原子性的？





## 索引篇

### 说下MySQL回表？

一般我们自己建的索引不管是单列索引还是联合索引，都是二类索引，索引B+ 树的节点仅仅包含了索引里的几个字段的值以及主键值。

根据索引树按照条件找到了需要的数据，仅仅是索引里的几个字段的值和主键值，还需要很多其他的字段，就得走一个回表操作，根据主键再到主键的聚簇索引里去找，聚簇索引的叶子节点是数据页，找到数据页里才能把一行数据的所有字段值提取出来。

### 索引失效的有哪些情况？





## SQL性能篇

### 表与表之间的连接方式和对性能的影响

表和表之间的连接方式分为四种：

1. 内关联：查出两表关联字段等值的数据。从数学的角度讲就是求两个表的交集，从笛卡尔积的角度讲就是从笛卡尔积中挑出ON子句条件成立的记录。
2. 左关联：以左表为中心，查出左表的全部数据，关联字段值不相等则右表查出的数据显示为空；从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。
3. 右关联：以右表为中心，查出右表的全部数据，关联字段值不相等则左表查出的数据显示为空；从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。
4. 全外关联：产生A和B的并集。对于没有匹配的记录，则以null做为值。MySQL中没全外连接，用左外连接和右外连接在union(union连接的是两个查询不是两张表)起来。

在性能上的区别是：

**左右关联的方式比内关联方式更慢**。

第一个原因是，外连接多返回了一部分左表没有返回的数据。

第二个原因是MySQL中支持的是嵌套循环算法，外表中的每一条记录与内表中的记录进行判断，假设外表的记录数为R，内表的记录数位S，外表记录越少，性能越高，所以尽可能小表驱动大表。`inner join`在连接的时候，mysql会自动选择较小的表来作为驱动表，从而达到减少循环次数的目的。我们在使用`left join`表的时候，默认是使用左表作为驱动表，那么此时左表的大小是我们来控制的，如果控制不当，左表比较大，那么自然循环次数也会变多，效率会下降。

### JOIN表外连接优化

1. left join选择小表作为驱动表（这部分基本是大家的共识）
2. 如果左表比较大，并且业务要求驱动表必须是左表，那么我们可以通过where条件语句，使得左表被过滤的小一些，主要原理和第一条类似
3. 关联字段给索引，因为在mysql的嵌套循环算法中，是通过关联字段进行关联，并查询的，所以给关联字段索引很必要
4. 如果sql里面有排序，请给排序字段加上索引，不然会造成排序使用全表扫描
5. 如果where条件中含有右表的非空条件（除开is null），则left join语句等同于join语句，可直接改写成join语句。 
6. 根据文档，MySQL能更高效地在声明具有相同类型和尺寸的列上使用索引。所以把表与表之间的关联字段给上encoding和collation（决定字符比较的规则）全部改成统一的类型
7. 右表的条件列一定要加上索引（主键、唯一索引、前缀索引等），最好能够使type达到range及以上（ref,eq_ref,const,system） 



## 场景篇

### 如果当前数据库查询CPU占用高，该如何定位问题

1. 首先通过通过查看mysql data目录里面的*.err文件，查询数据库是否运行正常

2. 运行正常时，通过`show processlist `语句，查找负荷最重的 SQL 语句

   > 对于查询时间长、运行状态（State 列）是“Sending data”、“Copying to tmp table”、“Copying to tmp table on disk”、“Sorting result”、“Using filesort”等都可能是有性能问题的查询（SQL）。

3. 通过explain 定位该SQL语句的性能问题并优化。





