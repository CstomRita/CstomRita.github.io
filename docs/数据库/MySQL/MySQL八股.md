@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>

## 基础篇

### MySQL中都有哪些数据类型？

分为五种大类型：

- 针对整型，TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间。
- 针对浮点数类型，有FLOAT 和 DOUBLE 浮点类型。
- 针对字符串，有CHAR 和 VARCHAR 两种类型，前者是定长的，后者是变长的。
- 针对日期类型，有datetime和timestamp类型。
- 针对大文件，有text和blob类型。

### BLOB和TEXT有什么区别？

BLOB 是一个二进制对象，可以容纳可变数量的数据。

TEXT 是一个不区分大小写的 BLOB。

BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时，区分大小写，对 TEXT 值不区分大小写。

### Char和Varchar的区别？

- char 表示定长字符串，长度是固定的；vachar表示可变字符串，长度是变化的。
- 如果插入数据的长度小于 char 的固定长度时，则用空格填充；在varchar中，插入的数据多长就按照多长来存储。
- Varchar因为长度固定，所以存取速度要比 varchar 快；但varchar不会占据多余空间
-  char 最多能存放的字符个数为 255；varchar最多能存放的字符为2的16次方-1。

### DateTime和TimeStamp的区别？

两个数据类型都是存储时间的类型，均为 `YYYY-MM-DD HH:MM:SS`

两种的不同的在于：

- 日期范围不同。DATETIME 的日期范围是 `1000-01-01 00:00:00.000000` 到 `9999-12-31 23:59:59.999999`；TIMESTAMP 的时间范围是`1970-01-01 00:00:01.000000` UTC `到 ``2038-01-09 03:14:07.999999` UTC。
- 存储空间不同。DATETIME 的存储空间为 8 字节；TIMESTAMP 的存储空间为 4 字节。
- 时区不同。DATETIME 存储时间与时区无关；TIMESTAMP 存储时间与时区有关，显示的值也依赖于时区。
- 默认值不同。DATETIME 的默认值为 null；TIMESTAMP 的字段默认不为空(not null)，默认值为当前时间。

###表连接的方式有哪几种？

1. 内关联：查出两表关联字段等值的数据。从数学的角度讲就是求两个表的交集，从笛卡尔积的角度讲就是从笛卡尔积中挑出ON子句条件成立的记录。
2. 左关联：以左表为中心，查出左表的全部数据，关联字段值不相等则右表查出的数据显示为空；从笛卡尔积的角度讲，就是先从笛卡尔积中挑出ON子句条件成立的记录，然后加上左表中剩余的记录。
3. 右关联：以右表为中心，查出右表的全部数据，关联字段值不相等则左表查出的数据显示为空；从笛卡尔积的角度描述，右连接就是从笛卡尔积中挑出ON子句条件成立的记录，然后加上右表中剩余的记录。
4. 全外关联：产生A和B的并集。对于没有匹配的记录，则以null做为值。MySQL中没全外连接，用左外连接和右外连接在union(union连接的是两个查询不是两张表)起来。

### 表与表之间的连接方式和对性能的影响

在性能上的区别是：

**左右关联的方式比内关联方式更慢**。

第一个原因是，外连接多返回了一部分左表没有返回的数据。

第二个原因是MySQL中支持的是嵌套循环算法，外表中的每一条记录与内表中的记录进行判断，假设外表的记录数为R，内表的记录数位S，外表记录越少，性能越高，所以尽可能小表驱动大表。`inner join`在连接的时候，mysql会自动选择较小的表来作为驱动表，从而达到减少循环次数的目的。我们在使用`left join`表的时候，默认是使用左表作为驱动表，那么此时左表的大小是我们来控制的，如果控制不当，左表比较大，那么自然循环次数也会变多，效率会下降。

### 什么是SQL注入，如何防范？

SQL注入是通过把SQL命令插入到表单提交或页面请求的查询字符串中，最终到达服务器执行恶意的SQL命令。

防范：

1. 不要相信用户的输入，对用户输入进行校验
2. 不要动态拼接SQL，使用参数化的SQL进行数据查询
3. 敏感信息要单独加密存放
4. 为每个应用赋予单独的权限



## 事务篇

###  事务还没提交的时候，redo log 能不能被持久化到磁盘？

事务还没有提交的时候，redo log 是有可能被持久化到磁盘的。

redolog 的具体落盘操作是这样的：在事务运行的过程中，MySQL 会先把日志写到 redolog buffer 中，等到事务真正提交的时候，再统一把 redolog buffer 中的数据写到 redolog 文件中。不过这个从 redolog buffer 写到 redolog 文件中的操作也就是 write 并不就是落盘操作了，这里仅仅是把 redolog 写到了文件系统的 page cache 上，最后还需要执行 fsync 才能够实现真正的落盘。

也就是说，redolog 其实存在三种状态：

1. 事务执行过程中，存在 MySQL 的进程内存中的 redolog buffer 中
2. 事务提交，执行 write 操作存在文件系统的 page cache 中，但是没有执行 fsync 操作持久化到磁盘
3. 事务提交，执行 fsync 操作持久化到磁盘

relog的刷盘时机有三种情况：

第一种情况：InnoDB 有一个后台线程，每隔 1 秒轮询一次，具体的操作是这样的：调用 write 将 redolog buffer 中的日志写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。而在事务执行中间过程的 redolog 都是直接写在 redolog buffer 中的，也就是说，一个没有提交的事务的 redolog，也是有可能会被后台线程一起持久化到磁盘的。

第二种情况：innodb_flush_log_at_trx_commit 设置是 1时，每次事务提交的时候，都执行 fsync 将 redolog 直接持久化到磁盘，假设事务 A 执行到一半，已经写了一些 redolog 到 redolog buffer 中，这时候有另外一个事务 B 提交，事务 B 要把 redolog buffer 里的日志全部持久化到磁盘，这时候，就会带上事务 A 在 redolog buffer 里的日志一起持久化到磁盘。

第三种情况：redo log buffer 占用的空间达到 redolo buffer 大小(由参数 innodb_log_buffer_size 控制，默认是 8MB)一半的时候，后台线程会主动写盘。不过由于这个事务并没有提交，所以这个写盘动作只是 write 到了文件系统的 page cache，仍然是在内存中，并没有调用 fsync ，此时并不会落盘。

### MVCC是什么？



### 说说MySQL中的锁？



### 都有哪些隔离级别，都会产生什么问题？



### MySQL是怎么实现这些隔离级别的？



### MySQL是如何实现持久化的？



### MySQL是如何保证原子性的？





## 索引篇

### 说下MySQL回表？

一般我们自己建的索引不管是单列索引还是联合索引，都是二类索引，索引B+ 树的节点仅仅包含了索引里的几个字段的值以及主键值。

根据索引树按照条件找到了需要的数据，仅仅是索引里的几个字段的值和主键值，还需要很多其他的字段，就得走一个回表操作，根据主键再到主键的聚簇索引里去找，聚簇索引的叶子节点是数据页，找到数据页里才能把一行数据的所有字段值提取出来。

### 索引失效的有哪些情况？

- 模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 查询条件中对索引列使用函数，就会导致索引失效。
- 查询条件中对索引列进行表达式计算，也是无法走索引的。
- 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则会导致数据库向字符串的隐式强制转换，从而不使用索引。这是因为不加括号的话，会自动把字符串隐式转换转为数字，等同于对索引列使用了函数，导致索引失效。
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。
- 对于多列复合索引，如果查询条件不是索引的第一部分，不会使用索引。

## 调优篇

### JOIN表外连接优化？

1. left join选择小表作为驱动表（这部分基本是大家的共识）
2. 如果左表比较大，并且业务要求驱动表必须是左表，那么我们可以通过where条件语句，使得左表被过滤的小一些，主要原理和第一条类似
3. 关联字段给索引，因为在mysql的嵌套循环算法中，是通过关联字段进行关联，并查询的，所以给关联字段索引很必要
4. 如果sql里面有排序，请给排序字段加上索引，不然会造成排序使用全表扫描
5. 如果where条件中含有右表的非空条件（除开is null），则left join语句等同于join语句，可直接改写成join语句。 
6. 根据文档，MySQL能更高效地在声明具有相同类型和尺寸的列上使用索引。所以把表与表之间的关联字段给上encoding和collation（决定字符比较的规则）全部改成统一的类型
7. 右表的条件列一定要加上索引（主键、唯一索引、前缀索引等），最好能够使type达到range及以上（ref,eq_ref,const,system） 

## 场景篇

### 如果当前数据库查询CPU占用高，该如何定位问题？

排查：

1. 首先使用 top 命令观察，确定是MySQL进程导致还是其他原因。

2. 如果确定是MySQL进程占用较高，查看data目录里面的*.err文件，查询数据库是否运行正常

3. 使用`show processlist`，查看确定是不是有消耗资源的 sql 在运行，也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。

   > 对于查询时间长、运行状态（State 列）是“Sending data”、“Copying to tmp table”、“Copying to tmp table on disk”、“Sorting result”、“Using filesort”等都可能是有性能问题的查询（SQL）。

3. 如果确实有消耗高的 sql，使用`explain`看看执行计划是否准确， 索引是否缺失，数据量是否太大，定位SQL语句的性能问题。

处理：

1. kill 掉这些线程 (同时观察 cpu 使用率是否下降)，
2. 进行相应的调整 (比如说加索引、改 sql、改内存参数)
3. 重新跑这些 SQL

### 慢SQL如何定位？

- 使用慢查询日志定位：开启 MySQL 的慢查询日志，再通过一些工具比如 mysql-dump-slow 去分析对应的慢查询日志。
- 使用show processlist定位：可以查询定位当前正在执行的慢查询。

### 如何优化SQL？

 SQL语句的优化可以注意以下方面：

- 避免不必要的列。SQL 查询的时候，应该只查询需要的列，而不要包含额外的列。
- 分页优化。在数据量比较大，考虑分页的优化。
- 索引优化。合理的设计和使用索引。
- 如果需要表的联合查询的话，尽可能用小表驱动大表，避免join太多的表，适当的增加冗余字段减少join查询。

### 大表如何增加字段？

当线上的数据库数据量到达几百万、上千万的时候，加一个字段就没那么简单，因为可能会长时间锁表。

通常的做法包括：

- 通过中间表转换：创建一个临时的新表，把旧表的结构完全复制过去，添加字段，再把旧表数据复制过去，删除旧表，新表命名为旧表的名称，这种方式可能回丢掉一些数据。
- 先在从库添加 再进行主从切换：如果一张表数据量大且是热表，读写特别频繁，则可以考虑先在从库添加，再进行主从切换，切换后再将其他几个节点上添加字段。

### 百万级别的数据如何删除？

MySQL中删除数据的速度和创建的索引数量是成正比的，索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的 IO,会降低增/改/删的执行效率。

因此，删除大量数据时，首先要先删除索引，之后再删除数据，删除完成之后重新创建索引。

