@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>



> 一个事务是可以被看作一个单元的一系列SQL语句的集合。



## 事务基础

### 事务ACID特性

事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：

- 只有满足一致性，事务的执行结果才是正确的。
- 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。
- 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
- 事务满足持久化是为了能应对系统崩溃的情况。

![image-20230826134018727](%E4%BA%8B%E5%8A%A1.assets/image-20230826134018727.png)

#### 原子性

**概念**

事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。

**实现**

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

#### 一致性

**概念**

数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对同一个数据的读取结果都是相同的。

#### 隔离性

**概念**

一个事务所做的修改在最终提交以前，对其它事务是不可见的。

#### 持久性

**概念**

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失

**实现**

系统发生崩溃可以用重做日志（Redo Log）进行恢复，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。

### 事务的分类

#### 扁平事务

所有操作处于同一个层次中，从BEGIN WORK开始事务

所有操作完成之后 COMMIT WORK提交事务 事务执行成功

如果在操作中间出现了失败，则ROLLBACK WORK回滚所有已经执行的操作

扁平事务的主要限制在于不能提交或者回滚事务的一部分，它要么全部提交，要么全部回滚

但是某些事务可能在执行过程中出现的错误并不会导致所有的操作都无效，放弃整个事务似乎不大合理，开销也很大

当我们想回滚到之前某个已经完成的节点上就需要带有保存点

#### 带有保存点的扁平事务

除了支持扁平化支持的操作，还允许事务执行过程中回滚到同一事务中较早的一个状态

保存点使用SAVE WORK函数用来通知系统应该记住事务的当前状态，当出现问题时保存点可以作为内部的重启动点，根据应用逻辑决定返回哪一个保存点

需要注意的是，保存点在事务内部是递增的，ROLLBACK不会影响保存点的计数

举例：当前Savepoint5，ROLLBACK返回savepoint2之后，此时事务依然处于活跃状态，如果继续回滚ROLLBACK WORK回滚所有操作，那么事务就不再活跃，如果继续操作调用SAVE WORK保存保存点是Savepoint是依然递增savepoint6而非在2的基础上

带有保存点的扁平事务的缺陷：

保存点是易失的，而非持久的

**带有保存点的扁平事务，当发生系统崩溃时所有的保存点都会消失，当进行恢复时事务需要从开始处重新执行而非最近的一个保存点继续执行**

#### 链事务

链事务是对保存点模式的一种变种

链事务的思想在于释放不需要的数据对象，将必要的处理上下文传递给下一个要开始的事务

**提交事务和开始下一个事务操作合并成一个原子操作**，这就意味着下一个事务将看到上一个事务的结果

链事务和带有保存点的扁平事务不同的是：

链事务仅限制于回滚当前事务，只能恢复到最近的一个保存点

链事务在执行完当前事务的COMMIT操作之后即释放了当前事务所持有的锁

而带有保存点的扁平事务不会影响持有的锁

#### 嵌套事务

嵌套事务是一个层次结构框架，由一个顶层事务控制着各个层次的事务，顶层事务之下嵌套的事务叫做子事务

1. 每一个子事务可以是一个扁平化事务，也可以 是一个嵌套事务
2. 处于叶节点的事务是扁平事务，根节点的叫做顶层事务
3. 子事务可以提交也可以回滚，事务提交需要等到父事务提交之后才能真正提交，如此遍历一切事务的提交都要等到顶层事务的提交；子事务的回滚会引起这个事务的所有子事务的回滚
4. 子事务不具有D的特性

不同的子事务在数据库对象中持有不同的对象锁

如果想实现事务间的并行，需要支持嵌套事务

#### 分布式事务 [单独说明]

分布式事务是在一个分布式环境下运行的**扁平事务**，根据**数据库所在位置**访问网络中不同节点

(数据部署在每一个节点上，在不同节点上对一个数据库操作的情况)

访问网络中多个节点的数据库，而每个节点上数据库的执行操作都是扁平事务 

分布式事务同样满足ACID特性，要么都发生要么都失效

### 并发一致性问题

在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。

#### 修改丢失

丢失修改指一个事务的更新操作被另外一个事务的更新操作替换。

![image-20230827135342420](%E4%BA%8B%E5%8A%A1.assets/image-20230827135342420.png)

例如：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改并提交生效，T2 随后修改，T2 的修改覆盖了 T1 的修改。

#### 脏读

读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。

![image-20230827135440224](%E4%BA%8B%E5%8A%A1.assets/image-20230827135440224.png)

例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。

#### 不可重复读

不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。

![image-20230827135536480](%E4%BA%8B%E5%8A%A1.assets/image-20230827135536480.png)

例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。

> 不可重复读和脏读区别在于，脏读读取的是其他事务**还未提交**的数据，不可重复读读取的是其他数据**提交之后**的数据

#### 幻读

幻读本质上也属于不可重复读的情况，T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。

![image-20230827135655735](%E4%BA%8B%E5%8A%A1.assets/image-20230827135655735.png)

> 幻读，在一定程度上表现和不可重复读一样
>
> 都是另外一个事务同时操作导致，所读取的数据不再相同
>
> 但两者的侧重不同：不可重复读表现在update/delete，另外一个事务修改这一行数据；幻读表现在insert，插入一条新的消费记录，使得账户余额不同
>
> 不可重复读仅仅锁住那一行记录行即可；但是幻读需要锁住的是整张表



### 隔离级别

| 隔离级别        |            | 可能导致的一致性问题   | 锁机制                                       |
| --------------- | ---------- | ---------------------- | -------------------------------------------- |
| READ UNCOMMIT   | 读未提交   | 脏读、不可重复读、幻读 | 忽略其他事务放置的锁                         |
| READ COMMITTED  | 不可重复读 | 不可重复读、幻读       | 不能读取其他事务未提交的数据，锁定行锁。     |
| REPEATABLE READ | 可重复读   | 幻读                   | 只锁定了某一行，不阻塞全表的insert           |
| SERIALIZABLE    | 串行化     | 无                     | 锁定整个范围的键，并一直持有锁，直到事务完毕 |

#### 读未提交

这是事务的最低级别，事务中的修改，即使没有提交，对其它事务也是可见的。

#### 读已提交

保证一个事务修改的数据提交后才能被另外一个事务读取，另外一个事务不能读取该事务未提交的数据。

换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

#### 可重复读

**这是MySQL的默认事务隔离级别**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。

#### 串行化

强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。

这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。



## 事务的使用

### InnoDB引擎

#### 开启一个事务

在InnoDB中分为自动开启自动提交，手动开启手动提交，自动开启手动提交三种情况：

| 提交机制 | 设置语句 | 说明 | SQL |
| --------------- | ------------------ | ------------------------------------------------------------ | ---------------------------------- |
| 自动 <br>开启自动提交 | set autocommit = 1 | 系统则默认用户对数据库的每一个SQL操作为一个孤立的事务，也就是说用户每进行一次操作系都会即时提交或者即时回滚。这种情况下用户的每一个SQL都是一个独立的事务 | SQL语句； COMMIT；                 |
| 手动开启手动提交 | set autocommit = 1 | 用户执行start transaction命令时一个事务开启，当用户执行commit命令时当前事务提交。从用户执行start transaction命令到用户执行commit命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。 | START TRANSACTION; SQL语句 COMMIT; |
| 自动开启手动提交 | set autocommit = 0 | 事务则在用户本次对数据进行操作时自动开启，在用户执行commit命令时提交，用户本次对数据库开始进行操作到用户执行commit命令之间的一系列操作为一个完整的事务周期。若不执行commit命令，系统则默认事务回滚。 | SQL语句                            |



## InnoDB引擎事务的实现

事务的持久性D通过数据库的redo log 实现；

事务的原子性A通过数据库的undo log实现；

事务隔离性I由锁和MVCC来完成。



### 持久性-redo log

#### redo log

redo log 【重做日志】是 InnoDB 引擎特有的日志， 是物理日志，记录的是“在某个数据页上做了什么修改”。

当事务提交时，必须先将事务的所有日志写入日志文件进行持久化，就是我们常说的WAL(write ahead log)机制，这样才能保证断电或宕机等情况发生后，已提交的事务不会丢失，这个能力称为 crash-safe。

#### redo log 写入流程

![image-20230827150435788](%E4%BA%8B%E5%8A%A1.assets/image-20230827150435788.png)

可以发现，更新操作的数据并没有直接写入磁盘，而且写入内存的buffer) pool ，**数据的持久化操作，是通过redo log 来完成的**。

Redo log包括两部分，重做日志缓冲(redo log buffer)和重做日志文件(redo log file)，前者是易失的缓存，后者是持久化的文件。

##### Redo log落盘

![img](%E4%BA%8B%E5%8A%A1.assets/5175b9c1e6939823a44a59c6eed27e1f.jpg)

在事务运行的过程中，MySQL 会先把日志写到 redolog buffer 中，等到事务真正提交的时候，再统一把 redolog buffer 中的数据写到 redolog 文件中。

从 redolog buffer 写到 redolog 文件中的操作，仅仅是把 redolog 写到了文件系统的 page cache系统缓存 上，最后还需要执行 fsync 才能够实现真正的落盘。

InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：

- innodb_flush_log_at_trx_commit = 0

每次事务提交的时候，都只是把 redolog 留在 redolog buffer 中，InnoDB 有一个后台线程，每隔 1 秒轮询一次，具体的操作是这样的：调用 write 将 redolog buffer 中的日志写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。

当 `innodb_flush_log_at_trx_commit `的值为 0 时性能好，由后台 Master 线程每隔 1秒执行一次操作，可能会丢失 master thread 还没刷进磁盘的这一秒内的事务数据。

- innodb_flush_log_at_trx_commit = 1

每次事务提交的时候，都执行 fsync 将 redolog 直接持久化到磁盘。

当 `innodb_flush_log_at_trx_commit` 的值为1 时，这是最安全、性能最差的方式。

> 举个例子，假设事务 A 执行到一半，已经写了一些 redolog 到 redolog buffer 中，这时候有另外一个事务 B 提交，按照 innodb_flush_log_at_trx_commit = 1 的逻辑，事务 B 要把 redolog buffer 里的日志全部持久化到磁盘，这时候，就会带上事务 A 在 redolog buffer 里的日志一起持久化到磁盘

- innodb_flush_log_at_trx_commit = 2

每次事务提交的时候，都只执行 write 将 redolog 写到文件系统的 page cache 中，后台线程一秒执行一次刷盘操作。

如 DB 发生故障，期望且操作系统也出现了宕机，文件系统中没有及时写入磁盘的数据就会丢失1s的数据。

##### 二阶段提交

二阶段提交其实指的就是redo log在事务过程中，两个状态【prepare/commit】的变化阶段

**为什么一定需要二阶段提交？**

假如redo log不涉及状态的变化，提交之前的操作是 写入redo log 和binlog

那么无论维护两份日志的先后顺序是怎样的，都有可能在中间出现宕机的情况，重启后会出现binlog和实际数据不一致的情况，而我们并没有依据证明哪个日志是合理的。而如果有二阶段提交，redo log的两个状态会帮助我们去作出抉择：

1. binlog没日志，redo log状态为prepare，则事务进行回滚操作
2. binlog 有日志，redo log状态为prepare，则事务进行提交操作

#### binglog

##### binglog的作用

binlog【归档日志】是Mysql sever层维护的一种二进制日志，与innodb引擎中的redo/undo log是完全不同的日志；其主要是用来记录对mysql数据更新或潜在发生更新的SQL语句，并以"事务"的形式保存在磁盘中；

作用主要有：

- 复制：MySQL Replication在Master端开启binlog，Master把它的二进制日志传递给slaves并回放来达到master-slave数据一致的目的
- 数据恢复：通过mysqlbinlog工具恢复数据
- 增量备份

##### Redo log和bin log的不同

redo log是innodb的存储引擎产生的，而binlog是数据库的server层实现的。换句话说，如果你使用MySQL，换其他存储引擎，那么可能没有redo log，但是还是会有binlog。

- 日志记录的内容形式不同。

binlog是一种逻辑日志，记录对应的SQL语句，而redo log记录了物理日志，是针对每个数据页的修改。

- 日志写入时间不同。

binlog只有在事务提交后完成一次写入，对于一个事物而言，在binlog中只有一条记录。而redo log在事务进行中不断被写入，而且是并发写入的，不是顺序写入的。![跟面试官侃半小时MySQL事务，说完原子性、一致性、持久性的实现-开源基础软件社区](%E4%BA%8B%E5%8A%A1.assets/6892e87507b8f9ad70a0999adb9a861e00824c.png)

- 保存方式不同。

redo log 是循环写的，空间固定会用完;binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

##### 为什么有了redo log，还需要binlog

在事务提交之前，同时维护redo log以及binlog的状态，我们称之为二阶段提交。

mysql 主从使用的是binlog ，如果我们单纯维护redo log，是可以达到宕机恢复数据的目的，但是从机就会出现丢失变更的情况。

所以为了达到宕机恢复、主从同步的目的，需要同时维护两份日志

### 原子性-undo log

Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。

**Undo log 的用途**

（1）保证事务进行rollback时的原子性，当事务进行回滚或者系统异常需要对数据进行回滚的的时候可以用undo log的日志进行数据重做。

（2）用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。





### 一致性

一致性的保证是从2个方面来保证的。

从数据库层面来看，就像一开始在定义的时候介绍的，事务的ACID性质不是完全正交的，尤其是一致性，我们可以认为原子性、持久性和隔离性都是为了实现事务的一致性，数据库必须要实现AID三大特性，才有可能实现一致性。

但是，如果你在事务里故意写出违反约束的代码，一致性还是无法保证的。例如，你在转账的例子中，你的代码里故意不给B账户加钱，那一致性还是无法保证。因此，还必须从应用层角度考虑。从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据！

### 隔离性

MVCC是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。

而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。

可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

#### MVCC

实现提交读和可重复读这两种隔离级别。

##### 基本思想

MVCC 利用了多版本的思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。

在 MVCC 中事务的修改操作（DELETE、INSERT、UPDATE）会为数据行新增一个版本快照，用链式结构串联起来。

##### 如何解决脏读和不可重复读

> 回顾一下，脏读和不可重复读是什么
>
> 脏读读取的是其他事务**还未提交**的数据，不可重复读读取的是其他数据**提交之后**的数据

脏读和不可重复读最根本的原因是事务读取到其它事务的修改。在事务进行读取操作时，为了解决脏读和不可重复读问题，MVCC 规定只能读取开始事务前可见的快照。



#### 锁

##### 锁的类型

对于MyISAM存储引擎都是表锁设计，InnoDB引擎中对锁做了细粒度设计。

| 锁类型  | 说明                                   |
| ------- | -------------------------------------- |
| S Lock  | 行锁，共享锁，允许读取一行数据         |
| X Lock  | 行锁，排它锁，允许删除修改一行数据     |
| IS LOCK | 表锁，意向共享锁，允许获取几行数据     |
| IX LOCK | 表锁，意向排它锁，允许删除修改几行数据 |

当事务要对一行数据上锁时，需要先对这个表单上意向锁，再去具体的一行数据上上锁

意向锁只会阻塞扫描全表的的请求

> 当前有一个事务对某一行数据读写，为表上了意向锁，有另外一个事务要对全表做一个update
>
> 如果没有意向锁，则需要扫描全表所有行来看有没有事务占据了行锁，十分占据资源
>
> 现在有了意向锁，如果发现当前表有意向锁，则全表的操作则会阻塞（这也是为什么要有意向锁）
>
> 而意向锁之间是没有冲突的，具体的冲突是两个事务获取同一行，加行锁的时候冲突；行锁上，只有共享锁和共享锁可以兼容，其他都会冲突

**读写锁**

- 互斥锁（Exclusive），简写为 X 锁，又称写锁。
- 共享锁（Shared），简写为 S 锁，又称读锁。

有以下两个规定：

- 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。
- 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。

**意向锁**

使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：

- 一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；
- 一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

**锁之间的兼容关系**

![image-20230827144035358](%E4%BA%8B%E5%8A%A1.assets/image-20230827144035358.png)

- 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
- 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

