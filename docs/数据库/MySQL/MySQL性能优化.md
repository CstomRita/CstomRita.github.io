@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>

## 优化总体方案

性能优化（Optimize）指的是在保证系统正确性的前提下，能够更快速响应请求的一种手段。而且有些性能问题，比如慢查询等，如果积累到一定的程度或者是遇到急速上升的并发请求之后，会导致严重的后果，轻则造成服务繁忙，重则导致应用不可用。因此在上线项目之前需要严格的把关，以确保 MySQL 能够以最优的状态进行运行。

### 优化方针

#### 注意事项

- 依据数据而不是凭空猜测
- 忌过早优化
- 忌过度优化
- 深入理解业务
- 性能优化是持久战
- 选择合适的衡量指标、测试用例、测试环境

#### 优化目标

- 减少 IO 次数，IO永远是数据库最容易瓶颈的地方，这是由数据库的职责所决定的，大部分数据库操作中超过90%的时间都是 IO 操作所占用的，减少 IO 次数是 SQL 优化中需要第一优先考虑，当然，也是收效最明显的优化手段。
- 降低 CPU 计算，除了 IO 瓶颈之外，SQL优化中需要考虑的就是 CPU 运算量的优化了。order by, group by,distinct … 都是消耗 CPU 的大户，当IO 优化做到一定阶段之后，降低 CPU 计算也就成为了重要目标

### 优化方案

MySQL数据库优化分为四个层面：

- 服务端优化
- 数据库结构优化
- SQL和索引优化
- 系统硬件优化

#### 服务端优化

1. 限流策略
2. 分流策略，请求转发，做负载均衡
3. 异步处理，提高并发量
4. 缓存机制，使用缓存中间件减少性能较低的磁盘IO操作次数
5. 如果可以的话，扩展服务器，增加机器量应对高峰

#### 数据库架构优化

##### 采用合适的存储引擎

![wxmp](MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/intro-4.png)

存储引擎类型：MyISAM、InnoDB、MEMORY、MERGE、TokuDB、CSV、Archive等。

- MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择该存储引擎是非常合适的。MyISAM是在Web、数据仓库和其他应用环境下最常使用的存储引擎之一。
- InnoDB：用于事务处理应用程序，支持外键。如果应用程序对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询外，还包括很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效地降低由于删除和更新导致地锁定，还可以确保事务地完整提交(Commit)和回滚(Rollback)，对于类似计费系统或者财务系统等对数据准确性要求较高地系统，InnoDB都是合适地选择。
- MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY的缺陷是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速访问结果。

##### 适当的分库分表、分区策略

分表是指当一张表中的字段更多时，可以尝试将一张大表拆分为多张子表，把使用比较高频的主信息放入主表中，其他的放入子表，这样我们大部分查询只需要查询字段更少的主表就可以完成了，从而有效的提高了查询的效率。

分库是指将一个数据库分为多个数据库。比如我们把一个数据库拆分为了多个数据库，一个主数据库用于写入和修改数据，其他的用于同步主数据并提供给客户端查询，这样就把一个库的读和写的压力，分摊给了多个库，从而提高了数据库整体的运行效率

分区操作：数据分区主要目的是为了在特定的SQL操作中减少数据读写的总量以缩减响应时间。当表中的数据量不断增大，查询数据的速度就会变慢，应用程序的性能就会下降，这时就应该考虑对表进行分区。表进行分区后，逻辑上表仍然是一张完整的表，只是将表中的数据在物理上存放到多个表空间(物理文件上)，这样查询数据时，不至于每次都扫描整张表

#### 表单结构和索引优化

##### 索引

可见MSQL基础-索引章节。

##### 对表单结构进行优化

**1 数据长度尽可能小**

一般说来数据库的表越小，那么它的查询速度就越快，因此为了提高表的效率，应该将表的字段设置的尽可能小，比如身份证号，可以设置为 char(18) 就不要设置为 varchar(18)。

**2 数据类型尽可能简单**

能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高。

**3 尽可能少定义text**

text 类型的查询效率很低，如果必须要使用 text 定义字段，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率。

#### SQL和索引优化

##### 优化方式

优化方式分为以下几点：

**1 减少请求的数据量**

- 只返回必要的列：最好不要使用 SELECT * 语句。
- 只返回必要的行：使用 LIMIT 语句来限制返回的数据。
- 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的

**2  检索扫描行数**

最有效的方式是使用索引来覆盖查询。

**3  切分大查询**

一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。

将一个查询分解，多个小查询，然后在应用程序中进行关联。

> 例如，将一个连接多个表的大查询，分解成对每一个表进行一次单表查询。
>
> 这样做的好处有：
>
> - 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。
> - 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。
> - 减少锁竞争；
> - 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。
> - 查询本身效率也可能会有所提升。



##### 慢查询

慢查询通常的排查手段是先使用慢查询日志功能，查询出比较慢的 SQL 语句，然后再通过 explain 来查询 SQL 语句的执行计划，最后分析并定位出问题的根源，再进行处理。

慢查询日志指的是在 MySQL 中可以通过配置来开启慢查询日志的记录功能，超过 long_query_time 值的 SQL 将会被记录在日志中。我们可以通过设置“slow_query_log=1”来开启慢查询，它的开启方式有两种：

- 通过 MySQL 命令行的模式进行开启，只需要执行“set global slow_query_log=1”即可，然而这种配置模式再重启 MySQL 服务之后就会失效； 
- 另一种方式可通过修改 MySQL 配置文件的方式进行开启，我们需要配置 my.cnf 中的“slow_query_log=1”即可，但这种方式配置完成之后需要重启 MySQL 服务器才可生效。

 需要注意的是，在开启慢日志功能之后，会对 MySQL 的性能造成一定的影响，因此在生产环境中要慎用此功能。

##### explain命令

mysql5.6的版本已经支持直接查看Update等非查询操作的执行计划

每行记录都包含了以下几个字段

- id：执行编号，标识 select 所属的行。如果语句当中没有子查询或联合查询，那么只会有唯一的 select，于是每一行在这个列中都将显示一个 1。否则，内层的 select 语句一般会顺序编号，对应于原始语句中的位置。

- select_type：select 查询的类型

  - SIMPLLE：简单查询，该查询不包含 UNION 或子查询
  - PRIMARY：如果查询包含 UNION 或子查询，则最外层的查询被标识为 PRIMARY
  - UNION：表示此查询是 UNION 中的第二个或者随后的查询
  - DEPENDENT：UNION 满足 UNION 中的第二个或者随后的查询，其次取决于外面的查询
  - UNION RESULT：UNION 的结果
  - SUBQUERY：子查询中的第一个 select 语句
  - DEPENDENT SUBQUERY：子查询中的 第一个 select，同时取决于外面的查询
  - DERIVED：派生表 select，包含在 from 字句的子查询中的查询
  - UNCACHEABLE SUBQUERY：满足是子查询中的第一个 select 语句，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中
  - UNCACHEABLE UNION：满足此查询是 UNION 中的第二个或者随后的查询，同时意味着 select 中的某些特性阻止结果被缓存于一个 Item_cache 中

- table：查询的是哪个表

- partitions：匹配的分区

- type：关联类型，或者访问类型 【重要】它指明了 MySQL 决定如何查找表中符合条件的行，同时为判断查询是否高效提供了重要的依据。

  - ALL：全表扫描，这个类型是性能最差的查询之一。通常来说，我们的查询不应该出现 ALL 类型，因为这样的查询，在数据量最大的情况下，对数据库的性能是巨大的灾难。

  - index：全索引扫描，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型是扫描全部的索引，主要优点是避免了排序，但是开销仍然非常大。如果在 Extra 列看到 Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要少很多。

  - range：范围扫描，就是一个有限制的索引扫描，它开始于索引里的某一点，返回匹配这个值域的行。这个类型通常出现在 =、<>、>、>=、<、<=、IS NULL、<=>、BETWEEN、IN() 的操作中，key 列显示使用了哪个索引，当 type 为该值时，则输出的 ref 列为 NULL，并且 key_len 列是此次查询中使用到的索引最长的那个。

  - ref：一种索引访问，也称索引查找，它返回所有匹配某个单个值的行。此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了最左前缀规则索引的查询。

  - eq_ref：使用这种索引查找，最多只返回一条符合条件的记录。在使用唯一性索引或主键查找时会出现该值，非常高效。

  - const、system：该表至多有一个匹配行，在查询开始时读取，或者该表是系统表，只有一行匹配。其中 const 用于在和 primary key 或 unique 索引中有固定值比较的情形。

  - NULL：在执行阶段不需要访问表

    > 该列取不同值的执行效率依次是
    >
    > ALL < index < range < ref < eq_ref < const < system < NULL
    >
    > 一般来说，至少要保证查询达到 range 级别，最好能达到 ref 级别。

- possible_keys：该查询可以选用的索引
- key：该查询选用的索引，**如果该索引没有出现在 possible_keys 列中，那么选用它可能出于另外的原因，比如，它可能选择了一个覆盖索引**。
- key_len：索引中使用的字节数，当 key 列的值为 NULL 时，则该列也是 NULL。如果正在使用的只是索引里的某些列，那么可以通过用该列的值算出来具体是哪些列。
- ref：显示上述表的连接匹配条件，即哪些列或常量被用于查询索引列上的值
- rows：估计为了找到所需行而要读取的行数，这个值是个估计值，原则上值越小越好。
- filtered：按表条件过滤的行的百分比，和 rows 相乘，表示和查询计划里前一个表关联的行数。
- Extra：额外的信息，该列显示了有关 MySQL 如何解析查询的其它信息
  - Using index：使用覆盖索引，表示查询索引就可查到所需数据，不用扫描表数据文件，往往说明性能不错。
  - Using Where：在存储引擎检索行后再进行过滤，使用了 where 从句来限制哪些行将与下一张表匹配或者是返回给用户。
  - Using temporary：在查询结果排序时会使用一个临时表，一般出现于排序、分组和多表 join 的情况，查询效率不高，建议优化。
  - Using filesort：对结果使用一个外部索引排序，而不是按索引次序从表里读取行，一般有出现该值，都建议优化去掉，因为这样的查询 CPU 资源消耗大。

> 注意的是：
>
> - EXPLAIN不会告诉你关于触发器、存储过程的信息或用户自定义函数对查询的影响情况
> - EXPLAIN不考虑各种Cache
> - EXPLAIN不能显示MySQL在执行查询时所作的优化工作部分
> - Explain 只是个近似结果
> - Explain 不会显示关于查询的执行计划的所有信息

#### 系统硬件优化

MySQL 对硬件的要求主要体现在三个方面：磁盘、网络和内存。

##### 磁盘

磁盘寻道能力（磁盘I/O）,以目前高转速SCSI硬盘(7200转/秒)为例，这种硬盘理论上每秒寻道7200次，这是物理特性决定的，没有办法改变;磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I/O 运行的时间，从而提高了 MySQL 整体的运行效率。 磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样。

#####  网络

保证网络宽带的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率。 DNS配置 尽量使用skip-name-resolve来减少因解析带来的不必要麻烦. 检查网络的ping 丢包率.。 通过优化/etc/sysctl.cnf 中的网络参数，提升性能。

##### 内存

MySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率。

## 分区

目前MySQL支持一下几种类型的分区：

- RANGE分区：基于一个给定区间边界，得到若干个连续区间范围，按照分区键的落点，把数据分配到不同的分区；

- LIST分区：类似RANGE分区，区别在于LIST分区是基于枚举出的值列表分区，RANGE是基于给定连续区间范围分区；

- HASH分区：基于用户自定义的表达式的返回值，对其根据分区数来取模，从而进行记录在分区间的分配的模式。这个用户自定义的表达式，就是MySQL希望用户填入的哈希函数。
- KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且使用MySQL 服务器提供的自身的哈希函数。

### RANGE分区

### LIST分区

### HASH分区

### KEY分区



## 分表

### 水平切分

水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

![img](MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/63c2909f-0c5f-496f-9fe5-ee9176b31aba.jpg)

#### 路由策略

什么是路由呢？就是数据应该分到哪一张表。

水平分表主要有三种路由方式。

##### 范围路由

选取有序的数据列 （例如，整形、时间戳等） 作为路由的条件，不同分段分散到不同的数据库表中。

我们可以观察一些支付系统，发现只能查一年范围内的支付记录，这个可能就是支付公司按照时间进行了分表。

![范围路由](MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/mysql-b3882ca3-1d04-44e2-9015-7e6c867255a0.jpg)

范围路由设计的复杂点主要体现在分段大小的选取上，分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适的分段大小。

范围路由的优点是：可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，只需要增加新的表就可以了，原有的数据不需要动。

范围路由的一个比较隐含的缺点是：分布不均匀，假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1000 条，而另外一个分段实际存储的数据量有 900 万条。

##### 哈希路由

选取某个列 （或者某几个列组合也可以） 的值进行 Hash 运算，然后根据 Hash 结果分散到不同的数据库表中。

同样以订单 id 为例，假如我们一开始就规划了 4 个数据库表，路由算法可以简单地用 id % 4 的值来表示数据所属的数据库表编号，id 为 12 的订单放到编号为 50 的子表中，id 为 13 的订单放到编号为 61 的字表中。

![Hash 路由](MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/mysql-e01e7757-c337-48c8-95db-2f7cfd2bc036.jpg)

Hash 路由设计的复杂点主要体现在初始表数量的选取上，表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题。

用了 Hash 路由后，增加子表数量是非常麻烦的，所有数据都要重分布。

Hash 路由的优缺点和范围路由基本相反，Hash 路由的优点是表分布比较均匀，缺点是扩充新的表很麻烦，所有数据都要重分布。

##### 配置路由

配置路由就是路由表，用一张独立的表来记录路由信息。同样以订单 id 为例，我们新增一张 order_router 表，这个表包含 orderjd 和 tablejd 两列 , 根据 orderjd 就可以查询对应的 table_id。

配置路由设计简单，使用起来非常灵活，尤其是在扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了。

![配置路由](MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/mysql-fcd34332-d38d-455a-875d-d4afd37cac72.jpg)

配置路由的缺点：

- 必须多查询一次，会影响整体性能；
- 路由表本身如果太大（例如，几亿条数据） ，性能同样可能成为瓶颈，如果我们再次将路由表分库分表，则又面临一个死循环式的路由算法选择问题。

### 垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

![img](MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/e130e5b8-b19a-4f1e-b860-223040525cf6.jpg)

## 分库

### 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于:

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

#### 读写分离分配

将读写操作区分开来，然后访问不同的数据库服务器，一般有两种方式：程序代码封装和中间件封装。

1. 程序代码封装

程序代码封装指在代码中抽象一个数据访问层（所以有的文章也称这种方式为 "中间层封装" ） ，实现读写操作分离和数据库服务器连接的管理。例如，基于 Hibernate 进行简单封装，就可以实现读写分离：

![业务代码封装](MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/mysql-771eb01f-3f1a-4437-8e1b-affe4de36ec3.jpg)业务代码封装

目前开源的实现方案中，淘宝的 TDDL (Taobao Distributed Data Layer, 外号：头都大了）是比较有名的。

2. 中间件封装

中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。

常见的mysql-proxy即为这样的一个中间件。

对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。

其基本架构是：

![img](MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/master-slave-proxy.png)

### 主从复制

MySQL 主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。

MySQL 默认采用异步复制方式，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。

#### 主从复制原理

- master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；
- slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件
- 同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。

![img](MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.assets/master-slave.png)

> - 主库会生成一个log dump线程，用来给从库I/O线程传binlog
>
> - 从库会生成两个线程,一个I/O线程,一个SQL线程:
>   - I/O线程，请求主库的binlog，并将得到的binlog写到本地的relay-log(中继日志)文件中；
>   - SQL线程，会读取relay log文件中的日志,并解析成sql语句逐一执行









