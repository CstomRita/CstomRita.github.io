@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>



## JVM和调优

### JVM

#### JVM的主要组成部分和作用

JVM包含两个子系统和两个组件，两个子系统为Class loader(类装载)、Execution engine(执行引擎)；两个组件为Runtime data area(运行时数据区)、Native Interface(本地接口)，其中：

1. Class loader(类装载)：根据给定的全限定名类名来装载class文件到JVM内存。
2. Execution engine（执行引擎）：执行classes中的指令。
3. Runtime data area(运行时数据区域)：这就是我们常说的JVM的内存。
4. Native Interface(本地接口)：与native libraries交互，是其它编程语言交互的接口。

#### JVM运行时数据区/JVM内存模型

**JVM运行时内存**划分成以下五个部分，注意这个JVM内存模型**<font color = red>是一个规范，是一个规范</font>**，对于不同的虚拟机、不同的版本可能会有不同的具体实现。

(无论怎么实现，规范依然是这个规范，理解规范和具体实现是不同的，例如永久代和方法区的不同就在这里，永久代是HotSpot虚拟机在1.7版本时对方法区规范的实现，其他虚拟机是没有这个实现、没有永久代这个概念的) 

1. 方法区：线程共享的，存储类信息、常量、静态变量、编译后代码等等。同样是不需要物理上内存连续、只要在逻辑上连续、大小可固定可扩展的一块区域，可能抛出OutOfMemoryerror异常。  
2. 堆：线程共享的，是JVM管理内存中最大的一块，在虚拟机启动时被创建，目的是存放对象实例、不需要物理上内存连续、只要在逻辑上连续、大小可固定可扩展的一块区域，所有的对象实例及数组都在堆上分配，也是GC的主要区域。可能抛出OutOfMemoryerror异常。
3. Java虚拟机栈：：也就是说这部分就是一个存放栈帧的栈，栈帧来存放局部变量表，操作数栈、动态链接、方法出口等信息，方法调用就是栈帧的入栈，方法执行完成就是栈帧出栈。是线程私有的，生命周期与线程一致，描述Java**方法**执行的内存模型，可能抛出stackoverflow异常已经outofmemoryerror异常。
4. 本地方法栈：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。线程私有的，可能抛出stackoverflow异常或者outofmemoryerror异常。
5. 程序计数器：是用来指示当前线程所执行字节码行号的一块小内存，线程私有的，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，是唯一一个没有内存溢出情况的区域。

![image-20230824191436145](Java%E5%85%AB%E8%82%A1.assets/image-20230824191436145.png)

#### JVM中的常量放在哪里 //todo



#### 具体说明堆中的内存结构

1. 1.7版本中，采用永久代实现方法区的规范，占有的依然是堆中的内存，在此版本中堆空间结构为： 

   主要分为新生代、老年代、永久代三大部分 

![img](Java%E5%85%AB%E8%82%A1.assets/D5B6C511-50BB-4FA5-B1EA-776C7A2204CC-2875800.png)

2. 在1.8版本中，不再使用老年代的方法实现方法区，反而采用了元空间(metaspace)的方式实现，元空间并不在虚拟机中，占有的是**本地内存**。

   此版本中堆空间结构仅有新生代、老年代两大部分，但是增加了一个本机内存元空间。 

![img](Java%E5%85%AB%E8%82%A1.assets/106C0CCC-4484-4F56-BC3F-B190D447AD82-2875800.png)

**Q：为什么做如此变化**

A:

1. 类和方法信息难以确定大小，所以难以指定永久代的大小，如果指定大了其他空间小了则容易造成老年代的溢出，指定小了则易造成永久代的溢出。 
2. 永久代的垃圾收集是和老年代(old generation)捆绑在一起的Full GC的，因此无论谁满了，都会触发永久代的垃圾收集，然而永久代的GC复杂度较高、而效率又很低。 
3. 使用本地内存，不占用堆的内存，不必权衡永久代的大小了，当元空间的内存大小超过额度时才会GC。

### 类加载





### GC //明天的

#### 简述GC机制



#### 如何判断一个对象是否可以回收？



#### JVM中的分代GC机制









