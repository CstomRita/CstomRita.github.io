@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>

## 基础

### 深拷贝和浅拷贝的区别？

浅拷贝：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。

深拷贝：在计算机中开辟一块**新的内存地址**用于存放复制的对象。

### Java中有哪些基础数据类型？

- byte: 占用 1 个字节，取值范围-128 ~ 127
- short: 占用 2 个字节，取值范围-2^15^ ~ 2^15^-1
- int：占用 4 个字节，取值范围-2^31^ ~ 2^31^-1
- long：占用 8 个字节
- float：占用 4 个字节
- double：占用 8 个字节
- char: 占用 2 个字节
- boolean：取决于具体虚拟机的实现，虚拟机规范中说明boolean值在编译之后都使用nt数据类型来代替，boolean数组共用byte类型数组的指令，满足虚拟机规范的情况下，boolean在数组情况下为1个字节，单个boolean为4个字节。

### 简述自动装箱拆箱？

对于 Java 基本数据类型，均对应一个包装类。

装箱就是自动将基本数据类型转换为包装器类型，如 int->Integer

拆箱就是自动将包装器类型转换为基本数据类型，如 Integer->int

### Java代码的执行顺序

- 父类静态代码块【静态变量-->静态代码块】
- 子类静态代码块【静态变量-->静态代码块】
- 父类构造代码块【非静态变量 --> 非静态代码块】
- 父类构造函数
- 子类非静态代码块【非静态变量 --> 非静态代码块】
- 子类构造函数

> 详细的先后顺序：父类静态变量、父类静态代码块、子类静态变量、子类静态代码块、父类非静态变量、父类非静态代码块、父类构造函数、子类非静态变量、子类非静态代码块、子类构造函数。

### 面向对象的三大特性？

继承：对象的一个新类可以从现有的类中派生，派生类可以从它的基类那继承方法和实例变量，且派生类可以修改或新增新的方法使之更适合特殊的需求。

封装：将客观事物抽象成类，每个类可以把自身数据和方法只让可信的类或对象操作，对不可信的进行信息隐藏。

多态：允许不同类的对象对同一消息作出响应。不同对象调用相同方法即使参数也相同，最终表现行为是不一样的。

### Java中多态？

Java 提供了两种用于多态的机制，分别是重载与覆盖。

- 重载：重载是指同一个类中有多个同名的方法，但这些方法有不同的参数，在编译期间就可以确定调用哪个方法。

- 覆盖：覆盖是指派生类重写基类的方法，使用基类指向其子类的实例对象，或接口的引用变量指向其实现类的实例对象，在程序调用的运行期根据引用变量所指的具体实例对象调用正在运行的那个对象的方法，即需要到运行期才能确定调用哪个方法

### 重载与覆盖的区别？

- 覆盖是父类与子类之间的关系，是垂直关系；重载是同一类中方法之间的关系，是水平关系。
- 覆盖只能由一个方法或一对方法产生关系；重载是多个方法之间的关系。
- 覆盖要求参数列表相同；重载要求参数列表不同。
- 覆盖中，调用方法体是根据对象的类型来决定的，而重载是根据调用时实参表与形参表来对应选择方法体。
- 重载方法可以改变返回值的类型，覆盖方法不能改变返回值的类型。

### 为什么要把 String 设计为不可变？

- 节省空间：字符串常量存储在 JVM 的字符串池中可以被用户共享。
- 提高效率：String 可以被不同线程共享，是线程安全的。在涉及多线程操作中不需要同步操作。
- 安全：String 常被用于用户名、密码、文件名等使用，由于其不可变，可避免黑客行为对其恶意修改。

### String/StringBuffer 与 StringBuilder

- String 类采用利用 final 修饰的字符数组进行字符串保存，因此不可变。如果对 String 类型对象修改，需要新建对象，将老字符和新增加的字符一并存进去。

- StringBuilder，采用无 final 修饰的字符数组进行保存，因此可变，但线程不安全。

- StringBuffer，采用无 final 修饰的字符数组进行保存，可变且线程安全。

### Java 反射机制是什么？

Java 反射机制是指在程序的运行过程中，可以构造任意一个类的对象、获取任意一个类的成员变量和成员方法、获取任意一个对象所属的类信息、调用任意一个对象的属性和方法。

反射机制使得 Java 具有动态获取程序信息和动态调用对象方法的能力。

可以通过以下类调用反射 API：

- Class 类：可获得类属性方法
- Field 类：获得类的成员变量
- Method 类：获取类的方法信息
- Construct 类：获取类的构造方法等等信息

## Object

###  `== `和 `equals()` 的区别

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。

`equals()` 用来判断两个对象是否相等，存在两种使用情况：

- 类没有重写 `equals()`方法：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。
- 类重写了 `equals()`方法：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

### hashcode的作用

`hashCode()` 的作用是获取哈希码（`int` 整数），也称为散列码。哈希码的作用是确定该对象在哈希表中的索引位置。

 `hashCode()` 和 `equals()`都是用于比较两个对象是否相等，但在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()`方法 之后，判断元素是否在对应容器中的效率会更高。

### hashcode和equals方法

 `hashCode()` 和 `equals()`都是用于比较两个对象是否相等，但在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()`方法 之后，判断元素是否在对应容器中的效率会更高，同样的 `hashCode` 有多个对象，它会继续使用 `equals()` 来判断是否真的相同。

由于哈希碰撞，两个对象的`hashCode` 值相等并不代表两个对象就相等。

总结下来就是：

- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等。

### 重写equals方法时必须重写hashcode方法吗？

重写 equals() 时必须重写 hashCode() 方法。

因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。

如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。

### hashcode返回一个常量会有什么问题？

当hashCode()返回常量时，所有对象都出现hash冲突，用哈希作key的时候效率会极度变低。

## String类

### String、StringBuffer、StringBuilder 的区别？

- 可变性上，`String` 是不可变的；StringBuffer和StringBuilder是可变的。
- 线程安全性上，`String` 中的对象是不可变的，也就可以理解为常量，线程安全；`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。
- 性能上，`String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象，性能较差；StringBuilder和StringBuffer对对象本身进行操作，比String性能高，由于StringBuffer线程安全，比StringBuilder性能高一点。

### String 为什么是不可变的?

1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。
2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

> 被 `final` 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象

### 字符串常量池的作用？

字符串常量池 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

### String s1 = new String("abc")创建了几个字符串对象？

会创建 1 或 2 个字符串对象。

- 如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。
- 如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。

> [!ATTENTION] 注意常量池的对象和堆中的对象是两个对象。

### intern 方法有什么作用?

`String.intern()` 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：

- 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。
- 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。

```java
// 在堆中创建字符串对象”Java“
// 将字符串对象”Java“的引用保存在字符串常量池中
String s1 = "Java";
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s2 = s1.intern();
// 会在堆中在单独创建一个字符串对象
String s3 = new String("Java");
// 直接返回字符串常量池中字符串对象”Java“对应的引用
String s4 = s3.intern();
// s1 和 s2 指向的是堆中的同一个对象
System.out.println(s1 == s2); // true
// s3 和 s4 指向的是堆中不同的对象
System.out.println(s3 == s4); // false
// s1 和 s4 指向的是堆中的同一个对象
System.out.println(s1 == s4); //true
```

