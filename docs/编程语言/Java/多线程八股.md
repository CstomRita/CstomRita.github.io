@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>

## 基础

### Java中可以使用哪些加锁机制？



### 如何避免死锁？

线程死锁值得是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。

预防死锁可以通过破坏死锁的产生的必要条件：

1. 破坏请求与保持条件：一次性申请所有的资源。
2. 破坏不剥夺条件：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. 破坏循环等待条件：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。
4. 在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

### ThreadLocal是什么？



### 线程有几种创建方式？

Java中创建线程主要有三种方式，分别为继承Thread类、实现Runnable接口、实现Callable接口。

### 多线程下会有哪些安全问题？

非线程安全的问题存在于实例变量中（堆/常量池中）共享内存的地方，如果是方法内部的私有变量存放在线程自己的方法栈局部变量中，也就不会存在线程安全问题了。

线程安全包括原子性和可见性：

1. 原子性：是指一个操作或多个操作要么全部执行，且执行的过程不会被任何因素打断，要么就都不执行，如果想操作是原子的，那么必须保证一个线程改写共享变量时，CPU2不能做缓存该共享变量的操作
2. 可见性：当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改。Java支持多个线程同时访问一个对象或者对象的成员变量，虽然对象和成员变量的内存是在共享内存中的，但是每个执行的线程可以拥有一份对该对象的缓冲区，读写都是在缓冲区进行的，之后再由于重排序随机时间内刷新到内存中，因此在执行过程中，一个线程看到的并不是最新的，这也是在多线程中

### 如何知道一个线程状态/任务是否已经执行完成？

1、在线程池内部，当一个任务丢给线程池去执行，线程池会调度工作线程来执行这个任务的run方法，run方法正常结束，也就意味着任务完成了。通过等待run方法返回，可以去统计任务的完成数量。

2、在线程池外部获得线程池内部任务的执行状态，有几种方法可以实现：

- isTerminated()方法，可以判断线程池的运行状态，可以调用isTerminated()方法了解线程池的运行状态，一旦线程池的运行状态是Terminated，意味着线程池中的所有任务都已经执行完了。想要通过这个方法获取状态的前提是，程序中主动调用了线程池的shutdown()方法。在实际业务中，一般不会主动去关闭线程池，因此这个方法在实用性和灵活性方面都不是很好。

- 在线程池中，有一个submit()方法，它提供了一个Future的返回值，我们通过Future.get()方法来获得任务的执行结果，当线程池中的任务没执行完之前，future.get()方法会一直阻塞，直到任务执行结束。因此，只要future.get()方法正常返回，也就意味着传入到线程池中的任务已经执行完成了。

- 可以引入一个CountDownLatch计数器，定义一个CountDownLatch对象并且计数器为1，接着在线程池代码块后面调用await()方法阻塞主线程，然后，当传入到线程池中的任务执行完成后，调用countDown()方法表示任务执行结束，计数器归零0，唤醒阻塞在await()方法的线程。

  ```java
  public static void main(String[] args) throws InterruptedException {
  	ExecutorService executorService= Executors.newFixedThreadPool(10); 		CountDownLatch countDownLatch=new CountDownLatch(1);		
      executorService.execute(new Runnable(){
          @Override
          public void run() {
              //开始执行任务 try {
              Thread.sleep(3000);//模拟任务执行时间
              countDownLatch.countDown();//任务执行结束后，计数器减1} catch
              (InterruptedException e){
                  e.printStackTrace();
              }});
          //阻塞main线程|当任务执行结束调用countDown()方法使得计数器归零后，唤醒主线程。 
          countDownLatch.await();
          executorService.shutdown( );
      }
  ```
