@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>



## 类加载机制

### 字节码

计算机是不能直接运行java代码的，必须要先运行java虚拟机，再由java虚拟机运行编译后的java代码。这个编译后的java代码，java字节码。

为什么jvm不能直接运行java代码呢，这是因为在cpu层面看来计算机中所有的操作都是一个个指令的运行汇集而成的，java是高级语言，只有人类才能理解其逻辑，计算机是无法识别的，所以java代码必须要先编译成字节码文件，jvm才能正确识别代码转换后的指令并将其运行。

#### 字节码文件-class

编译后的class文件就是字节码文件。

class文件本质上是一个以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在class文件中。jvm根据其特定的规则解析该二进制数据，从而得到相关信息。

以文本的形式打开class文件，就是二进制流

```txt
cafe babe 0000 0034 0013 0a00 0400 0f09
0003 0010 0700 1107 0012 0100 016d 0100
0149 0100 063c 696e 6974 3e01 0003 2829
5601 0004 436f 6465 0100 0f4c 696e 654e
756d 6265 7254 6162 6c65 0100 0369 6e63
0100 0328 2949 0100 0a53 6f75 7263 6546
696c 6501 0009 4d61 696e 2e6a 6176 610c
0007 0008 0c00 0500 0601 0010 636f 6d2f
7268 7974 686d 372f 4d61 696e 0100 106a
6176 612f 6c61 6e67 2f4f 626a 6563 7400
```

每个class文件包含的信息与结构如下：

![img](JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/java-jvm-class-2.png)

#### 字节码文件结构

##### 字节码文件信息

文件开头的7行信息包括:Class文件当前所在位置，最后修改时间，文件大小，MD5值，编译自哪个文件，类的全限定名，jdk次版本号，主版本号。

然后紧接着的是该类的访问标志：ACC_PUBLIC, ACC_SUPER，访问标志的含义如下:

| 标志名称       | 标志值 | 含义                                                         |
| -------------- | ------ | ------------------------------------------------------------ |
| ACC_PUBLIC     | 0x0001 | 是否为Public类型                                             |
| ACC_FINAL      | 0x0010 | 是否被声明为final，只有类可以设置                            |
| ACC_SUPER      | 0x0020 | 是否允许使用invokespecial字节码指令的新语义．                |
| ACC_INTERFACE  | 0x0200 | 标志这是一个接口                                             |
| ACC_ABSTRACT   | 0x0400 | 是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假 |
| ACC_SYNTHETIC  | 0x1000 | 标志这个类并非由用户代码产生                                 |
| ACC_ANNOTATION | 0x2000 | 标志这是一个注解                                             |
| ACC_ENUM       | 0x4000 | 标志这是一个枚举                                             |

##### 常量池

常量池可以理解成Class文件中的资源仓库。

主要存放的是两大类常量，字面量和符号引用：

1. 字面量类似于java中的常量概念，如文本字符串String，final常量等。

> 需要说明的一点，存在于常量池的字面量，指的是数据的值
>
> 比如 String s = "abc";存在常量池中的值是abc。

2. 符号引用则属于编译原理方面的概念，包括以下三种:

- 类和接口的全限定名(Fully Qualified Name)
- 字段的名称和描述符号(Descriptor)
- 方法的名称和描述符，参数类型+返回值。

##### 方法表集合

在常量池之后的是对类内部的方法描述，在字节码中以表的集合形式表现

##### 其他

#### 字节码增强 [//补充技术和使用方式]

字节码增强技术相当于是一把打开运行时JVM的钥匙，利用它可以动态地对运行中的程序做修改，也可以跟踪JVM运行中程序的状态。

平时使用的动态代理、AOP也与字节码增强密切相关，它们实质上还是利用各种手段动态生成符合规范的字节码文件。

##### ASM //补充使用方式

对于需要手动操纵字节码的需求，可以使用ASM，它可以直接生产 .class字节码文件，也可以在类被加载入JVM之前动态修改类行为。

ASM的应用场景有AOP（Cglib就是基于ASM）、热部署、修改其他jar包中的类等。

![img](JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/java-class-enhancer-2.png)



##### Javassist

**介绍**

ASM是在指令层次上操作字节码的，在指令层次上操作字节码的框架实现起来比较晦涩。

Javassist是一种强调源代码层次操作字节码的框架。利用Javassist实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类。

**使用方式**

最重要的是ClassPool、CtClass、CtMethod、CtField这四个类：

- CtClass（compile-time class）：编译时类信息，它是一个class文件在代码中的抽象表现形式，可以通过一个类的全限定名来获取一个CtClass对象，用来表示这个类文件。
- ClassPool：从开发视角来看，ClassPool是一张保存CtClass信息的HashTable，key为类名，value为类名对应的CtClass对象。当我们需要对某个类进行修改时，就是通过pool.getCtClass(“className”)方法从pool中获取到相应的CtClass。
- CtMethod、CtField：这两个比较好理解，对应的是类中的方法和属性。

一个demo：对Base中的process()方法做增强，在方法调用前后分别输出”start”和”end”，实现代码如下：

```java
 				ClassPool cp = ClassPool.getDefault();
        CtClass cc = cp.get("meituan.bytecode.javassist.Base");
        CtMethod m = cc.getDeclaredMethod("process");
        m.insertBefore("{ System.out.println(\"start\"); }");
        m.insertAfter("{ System.out.println(\"end\"); }");
        Class c = cc.toClass();
        cc.writeFile("/Users/zen/projects");
        Base h = (Base)c.newInstance();
        h.process();
```

我们需要做的就是从pool中获取到相应的CtClass对象和其中的方法，然后执行method.insertBefore和insertAfter方法，参数为要插入的Java代码，再以字符串的形式传入即可。

### 类加载机制

Class文件存储的所有信息要加载到虚拟机中，才能够运行和使用，将class文件加载到内存、并对数据校验解析、初始化，最终形成虚拟机可以直接使用Java类型的过程就是虚拟机类加载机制。 

#### ❗️❗️类加载过程

类从加载到虚拟机内存开始，到卸载内存为止，类的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载七个过程。 

![img](Java%E5%85%AB%E8%82%A1.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x1b19ib2tl,size_16,color_FFFFFF,t_70.png)

其中，类加载的过程包括了加载、验证、准备、解析、初始化五个阶段，验证、准备、解析三个过程统称为链接。

在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。

<font color=red>**注意📢📢这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。**</font>

##### 加载

加载过程就是把class字节码文件载入到虚拟机中。

加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情:

- 通过一个类的全限定名来获取其定义的二进制字节流。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时常量池。
- 在java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。



**加载class的方式**

- 从本地系统中直接加载
- 通过网络下载.class文件
- 从zip，jar等归档文件中加载.class文件
- 从专有数据库中提取.class文件
- 将Java源文件动态编译为.class文件

##### 验证

验证的目的是确保class文件的字节流中信息符合虚拟机的要求，不会危害虚拟机安全。

验证阶段大致会完成4个阶段的检验动作:

- 文件格式验证：验证字节流是否符合Class文件格式的规范；例如: 是否以`0xCAFEBABE`开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。
- 元数据验证：对字节码描述的信息进行语义分析(注意: 对比`javac`编译阶段的语义分析)，以保证其描述的信息符合Java语言规范的要求；例如: 这个类是否有父类，除了`java.lang.Object`之外。
- 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
- 符号引用验证：确保解析动作能正确执行。

验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用`-Xverifynone`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

##### 准备

准备阶段的工作就是为类的静态变量分配内存并设为jvm默认的初值，**这些内存都将在方法区中分配**，对于非静态的变量，则不会为它们分配内存。

- 这时候进行内存分配的仅包括类static静态变量。实例变量会在对象实例化时随着对象一块分配在Java堆中。
- **这里所设置的初始值通常情况下是数据类型默认的零值**(如`0`、`0L`、`null`、`false`等)，而不是被在Java代码中被显式地赋予的值。
- **特殊的，如果是被static final修饰的常量，会在javac编译时生成ConstantValue属性，在类加载的准备阶段直接把ConstantValue的值赋给该字段。可以理解为在编译期即把结果放入了常量池中**。

> 例如：假设一个类变量的定义为: `public static int value = 3`；
>
> 那么变量value在准备阶段过后的初始值为`0`，而不是`3`，因为这时候尚未开始执行任何Java方法，而把value赋值为3的`put static`指令是在程序编译后，存放于类构造器`()`方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。

> 如果是static final修饰，常量，准备阶段会设置实际值123 
>
> public static final int value = 123;

##### 解析

虚拟机将常量池中的符号引用替换为直接引用，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、调用点等7类符号引用。

- **符号引用**：以一组符号来描述所引用的目标，其与虚拟机的内存布局无关，引用的目标并不一定已经加载到内存。
- **直接引用**：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，如果有了直接引用，那引用的目标必定在内存中存在。

**Java虚拟机规范没有规定解析阶段发生的具体时间**，只要求了在执行anewarray、checkcast、getfield、getstatic、instanceof等等16个用于操作符号引用的字节码指令之前，先对他们所使用的的符号引用进行解析。

所以虚拟机可以选在在类被加载时就对常量池中的符号引用进行解析，也可以在一个符号引用将要被使用前才去解析。

**类或者接口解析**

要把一个类或者接口的符号引用解析为直接引用，需要以下三个步骤：

1. 如果该符号引用不是一个数组类型，那么虚拟机将会把该符号代表的全限定名称传递给类加载器去加载这个类。这个过程由于涉及验证过程所以可能会触发其他相关类的加载。
2. 如果该符号引用是一个数组类型，并且该数组的元素类型是对象。我们知道符号引用是存在方法区的常量池中的，该符号引用的描述符会类似”[java/lang/Integer”的形式，将会按照上面的规则进行加载数组元素类型，如果描述符如前面假设的形式，需要加载的元素类型就是java.lang.Integer ,接着由虚拟机将会生成一个代表此数组对象的直接引用。
3. 如果上面的步骤都没有出现异常，那么该符号引用已经在虚拟机中产生了一个直接引用，但是在解析完成之前需要对符号引用进行验证，主要是确认当前调用这个符号引用的类是否具有访问权限，如果没有访问权限将抛出java.lang.IllegalAccess异常。

**字段解析**

对字段的解析需要首先对其所属的类进行解析，因为字段是属于类的，只有在正确解析得到其类的正确的直接引用才能继续对字段的解析。对字段的解析主要包括以下几个步骤：

1. 如果该字段符号引用就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，解析结束
2. 否则，如果在该符号的类实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果在接口中包含了简单名称和字段描述符都与目标相匹配的字段，那么久直接返回这个字段的直接引用，解析结束
3. 否则，如果该符号所在的类不是Object类的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都相匹配的字段，那么直接返回这个字段的直接引用，解析结束
4. 否则，解析失败，抛出java.lang.NoSuchFieldError异常

**类方法解析**

进行类方法的解析仍然需要先解析此类方法的类，在正确解析之后需要进行如下的步骤：

1. 类方法和接口方法的符号引用是分开的，所以如果在类方法表中发现class_index（类中方法的符号引用）的索引是一个接口，那么会抛出java.lang.IncompatibleClassChangeError的异常
2. 如果class_index的索引确实是一个类，那么在该类中查找是否有简单名称和描述符都与目标字段相匹配的方法，如果有的话就返回这个方法的直接引用，查找结束
3. 否则，在该类的父类中递归查找是否具有简单名称和描述符都与目标字段相匹配的字段，如果有，则直接返回这个字段的直接引用，查找结束
4. 否则，在这个类的接口以及它的父接口中递归查找，如果找到的话就说明这个方法是一个抽象类，查找结束，返回java.lang.AbstractMethodError异常
5. 否则，查找失败，抛出java.lang.NoSuchMethodError异常
6. 如果最终返回了直接引用，还需要对该符号引用进行权限验证，如果没有访问权限，就抛出java.lang.IllegalAccessError异常

**接口方法解析**

同类方法解析一样，也需要先解析出该方法的类或者接口的符号引用，如果解析成功，就进行下面的解析工作：

1. 如果在接口方法表中发现class_index的索引是一个类而不是一个接口，那么也会抛出java.lang.IncompatibleClassChangeError的异常
2. 否则，在该接口方法的所属的接口中查找是否具有简单名称和描述符都与目标字段相匹配的方法，如果有的话就直接返回这个方法的直接引用。
3. 否则，在该接口以及其父接口中查找，直到Object类，如果找到则直接返回这个方法的直接引用
4. 否则，查找失败



##### 初始化

前面的类加载过程中，除了加载阶段用户可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。

到了初始化阶段，才真正开始执行类中定义的Java代码。在准备阶段，类变量已经赋过一次初始值了，而在初始化阶段，则会根据程序员的意志去初始化类变量和其他资源：**执行类构造器方法()**。

关于<clinit>方法：<clinit>()方法由编译器自动收集类中的所有<font color=red>**类变量的赋值动作**和**静态语句块（static{}）中的语句**</font>合并产生，收集的顺序由语句在源文件中出现的顺序所决定，静态语句块只能访问到定义在静态语句块之前的变量，对于定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。

> <clinit>()方法与实例构造器方法<init>()不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。所以在虚拟机中第一个被执行的<clinit>()方法肯定是java.lang.Object。
>
> 由于父类的<clinit>()方法先执行，所以父类中定义的静态语句块要优先于子类的变量操作。
>
> <clinit>()方法对于类或接口来说不是必需的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法。

##### 使用

类访问方法区内的数据结构的接口， 对象是Heap区的数据。

##### 卸载

在类使用完之后，如果满足下面的情况，类就会被卸载：

- 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。
- 加载该类的ClassLoader已经被回收。
- 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

如果以上三个条件全部满足，jvm就会在方法区垃圾回收的时候对类进行卸载，类的卸载过程其实就是在方法区中清空类信息，java类的整个生命周期就结束了。

##### 总结

![image-20230825001112312](JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/image-20230825001112312.png)

![image-20230825000047498](JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/image-20230825000047498.png)





#### 常量池详解

JVM常量池主要分为Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池。

涉及一些类加载和内存空间的只是，结合来看。

##### Class文件常量池

就是上面说的class文件结构中的一部分，一个class文件就有一个常量池，它只是class文件中的一个结构，并不是JVM内存。

![img](JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/20141011111433728.png)

包含的内容有：

- 数量值
- 字符串值
- 类引用
- 字段引用
- 方法引用

##### 运行时常量池

是JVM内存方法区的一部分，在类加载过程中，运行时常量池除了导入class文件常量池的内容，还会保存符号引用对应的直接引用(实际内存地址)。运行时常量池用来动态获取类信息，包括：class文件元信息描述、编译后的代码数据、引用类型数据、类文件常量池等。

<font color=red>运行时常量池是在类**加载**完成之后，将每个class常量池中的符号引用值转存到运行时常量池中。每个class都有一个运行时常量池，类在**解析**之后将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</font>

要注意的是，运行时常量池中保存的“常量”依然是`字面量`和`符号引用`。比如字符串，这里放的仍然是单纯的文本字符串，并没有Java中对象类型的概念，不是String对象。Java中的常量其实也是一个对象，例如 String s = "abc"，常量abc还要指向一个String对象的引用。

【👆👆👆上面一定要理解】

```java
String s0 = "hellow";
String s1 = new String("hellow");
```

第一种方式声明的字面量hellow是在编译期就已经确定的，它会直接进入class文件常量池中；当运行期间在全局字符串常量池中会保存它的一个引用，实际上最终还是要在堆上创建一个”hellow”对象。

第二种方式方式使用了new String()，也就是调用了String类的构造函数，我们知道new指令是创建一个类的实例对象并完成加载初始化的，因此这个字符串对象是在运行期才能确定的，创建的字符串对象是在堆内存上。

因此此时调用System.out.println(s0 == s1)；返回的肯定是flase,因此==符号比较的是两边元素的地址，s1和s0都存在于堆上，但是地址肯定不相同。

> 这里需要强调一下**不同的类共用一个运行时常量池**，同时在进入运行时常量池的过程中，多个class文件中常量池相同的字符串，多个class文件中常量池中相同的字符串只会存在一份在运行时常量池，这也是一种优化。

> 运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。



##### 字符串常量池

是JVM用来维护字符串实例的一个引用表，是一个HashTable，符串的字面量作为key，实际堆中创建的String对象的引用作为value。

字符串常量池和运行常量池是完全不同的概念。

**字符串常量池逻辑**

class文件里常量池里大部分数据会被加载到“运行时常量池”，包括String的字面量；但同时“Hello”字符串的一个引用会被存到同样在“非堆”区域的“字符串常量池”中，而"Hello"本体还是和所有对象一样，创建在Java堆中。

当主线程开始创建s1时，虚拟机会先去字符串池中找是否有equals(“Hello”)的String，如果相等就把在字符串池中“Hello”的引用复制给s1；如果找不到相等的字符串，就会在堆中新建一个对象，同时把引用驻留在字符串池，再把引用赋给str。

当用字面量赋值的方法创建字符串时，无论创建多少次，只要字符串的值相同，它们所指向的都是堆中的同一个对象。

![image-20230825000918097](JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/image-20230825000918097.png)

**String"字面量" 是何时进入字符串常量池的?**

采用懒加载机制，只有**当此字符串字面量被调用时**（如对其执行ldc字节码指令，将其添加到栈顶），HotSpot VM才会对其进行resolve，为其在字符串常量池中创建对应的String实例。

加载类的时候，那些字符串字面量会进入到当前类的运行时常量池，不会进入全局的字符串常量池（即在StringTable中并没有相应的引用，在堆中也没有对应的对象产生）

在遇到String类型常量时，resolve的过程如果发现StringTable已经有了内容匹配的java.lang.String的引用，则直接返回这个引用，反之，如果StringTable里尚未有内容匹配的String实例的引用，则会在Java堆里创建一个对应内容的String对象，然后在StringTable记录下这个引用，并返回这个引用出去。

**字符串常量池在 Java 内存区域的哪个位置**

在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代。

![在这里插入图片描述](JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/5zurtmhuop.jpeg)

在JDK1.7字符串常量池和静态变量被从方法区拿到了堆中，运行时常量池剩下的还在方法区, 也就是hotspot中的永久代。

![在这里插入图片描述](JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.assets/hxe17c2g69.jpeg)

在JDK8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆，运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间(Metaspace) 

![在这里插入图片描述](https://ask.qcloudimg.com/http-save/yehe-1161110/l0mpfn8tpl.jpeg)

##### JAVA 基本类型的封装类及对应常量池

Java中基本类型的包装类的大部分都实现了常量池技术，这些类Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。

另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。

```java
 			//在值小于127时可以使用常量池
        Integer i1=127;
        Integer i2=127;
        System.out.println(i1==i2);//输出true

        //值大于127时，不会从常量池中取对象
        Integer i3=128;
        Integer i4=128;
```

#### 类加载的时机

什么情况需要开始类加载过程的第一阶段：加载。Java虚拟机规范中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。

但是对于初始化阶段，虚拟机规范则严格规定了以下几种情况必须立即对类进行初始化，如果类没有进行过初始化，则需要先触发其初始化。在初始化之前，若还没被加载，要先被加载。

**主动引用和被动引用，主动引用会引起类的初始化，而被动引用不会引起类的初始化**

##### 主动引用

jvm有严格的规定，**当且仅当**以下五种情况,也就是**主动引用**，才会触发类的初始化：

1. 遇到new，getstatic，putstatic，invokestatic这4条字节码指令时，假如类还没进行初始化， 则马上对其进行初始化工作。 其实就是3种情况：
   1. 用new实例化一个类时
   2. 读取或者设置类的静态字段时（不包括被final修饰的静态字段， 因为他们已经被塞进常量池了）
   3. 执行静态方法的时
2. 使用java.lang.reflect.*的方法对类进行反射调用的时候， 如果类还没有进行过初始化，马上对其进行。
3. 初始化一个类的时候，如果他的父亲还没有被初始化，则先去初始化其父亲。
4. 当jvm启动时，用户需要指定一个要执行的主类（包含static void main(String[] args)的那个类）， 则jvm会先去初始化这个类。
5. 用Class.forName(String className);来加载类的时候，也会执行初始化动作。
   - 注意:ClassLoader的loadClass(String className);方法只会加载并编译某类，并不会对其执行初始化。

##### 被动引用

1. 引用父类的静态字段，只会引起父类的初始化，而不会引起子类的初始化。
2. 定义类数组，不会引起类的初始化。
3. 引用类的static final常量，不会引起类的初始化（如果只有static修饰，还是会引起该类初始化的）

##### 注意

特别需要指出的是，**类的实例化**与**类的初始化**是两个完全不同的概念：

- 类的实例化是指创建一个类的实例(对象)的过程；
- 类的初始化是指为类中各个类成员(被static修饰的成员变量)赋初始值的过程，是类生命周期中的一个阶段。

#### 类加载器