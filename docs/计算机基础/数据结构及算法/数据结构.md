@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>

## 二叉树

![image-20231113161334671](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20231113161334671.png)

### 满二叉树

![image-20231113161411098](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20231113161411098.png)

所有内部节点都有两个子节点，最底一层是叶子节点。

- 如果一颗树深度为h，最大层数为k，且深度与最大层数相同，即k=h;

- 第k层的结点数是：2^(k-1)

- 总结点数是：2^k-1 (2的k次方减一)

- 总节点数一定是奇数。

- 树高：h=log2(n+1)

### 完全二叉树

![image-20231113161530195](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20231113161530195.png)

若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h 层所有的结点都连续集中在最左边，这就是完全二叉树。

- 深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。

- 树高h=log2n + 1

- 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树

### 二叉查找树BST

二叉排序树本质是一棵二叉树，它的特别之处在于：

- 对于树中的每个结点，如果它有左子树，那么左子树上所有结点的值都比该结点小；
- 对于树中的每个结点，如果它有右子树，那么右子树上所有结点的值都比该结点大

![image-20231113145341762](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20231113145341762.png)

```java
class Node{
  Object data;
  Node left;
  Node right;
}
```

#### 查找

##### 思路

在二叉排序树中查找目标元素，就是从树根结点出发，先将树根结点和目标元素做比较：

- 若当前结点不存在，则查找失败；若当前结点的值和目标元素相等，则查找成功；
- 若当前结点的值比目标元素大，目标元素只可能位于当前结点的左子树中，继续进入左子树查找；
- 若当前结点的值比目标元素小，目标元素只可能位于当前结点的右子树中，继续进入右子树查找；

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2-220H51210144P.gif)

以上图的二叉排序树为例，查找元素 32 的过程是：

- 从树根结点出发，41 比目标元素 32 大，则 32 只可能位于 41 的左子树中，继续进入左子树查找；
- 当前子树的根结点 20 比目标元素 32 小，则 32 只可能位于 20 的右子树中，继续进入右子树查找；
- 当前子树的根结点 29 比目标元素 32 小，则 32 只可能位于 29 的右子树中，继续进入右子树查找；
- 当前子树只有一个根结点 32，和目标元素相等，正是要找的目标元素

##### 实现

```java
public Node find(int value) {

    Node current = root;

    while(current.val != value) {

        if(value < current.val) {
            current = current.leftChild;
        }
        else {
            current = current.rightChild;
        }
        if(current == null) {
            return null;
        }
    }

    return current;
}
```

#### 插入

##### 思路

二叉排序树中各个结点的值都不相等，因此新插入的元素一定是原二叉排序树没有的，否则插入操作会失败。此外插入新元素后，必须保证整棵树还是一棵二叉排序树。

二叉排序树插入新元素的方法是：在树中查找新元素，最终查找失败时找到的位置，就是放置新元素的位置。

在上图的二叉排序树中插入新元素 30，在树中查找 30，最终查找失败时找到的位置是结点 32 的左孩子，直接将 30 作为 32 的左孩子即可。

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2-220H5121024301.gif)

##### 实现

```java
public void insert(int data) {
        Node  newNode = new Node();
        newNode.val = data;     
        if(root == null) {
            //如果是第一个节点，也就是根节点为null,直接创建一个新的节点即可　
            root = newNode;
        }
        else {
            Node current = root;
            //current节点的父节点
            Node parent;
            //循环查找插入的位置
            while(true) {
                parent = current;
                //如果插入的值小于当前节点的值，从左子树查找
                if(data < current.val) {
                    current = current.leftChild;
                    //直到当前节点为null
                    if(current == null) {
                        //设置当前节点的父节点的左子节点为新创建的节点
                        parent.leftChild = newNode;
                        return;
                    }

                }
                //如果插入的值大于当前节点的值，从左子树查找
                else {
                    current = current.rightChild;
                    //直到当前节点为null
                    if(current == null) {
                        //设置当前节点的父节点的右子节点为新创建的节点
                        parent.rightChild = newNode;
                        return;
                    }
                }
            }// end of while(true)
        }   
    }
```



#### 删除

##### 思路

删除二叉排序树中已有的元素，必须确保整棵树还是一棵二叉排序树。

假设被删除的元素是 P，删除的同时需要妥善处理它的左、右子树。根据结点 P 是否有左、右孩子，可以归结为以下 3 种情况：

1. P 是叶子结点：可以直接摘除，整棵树还是二叉排序树。

2. P 只有一个孩子（左孩子或右孩子）：若 P 是双亲结点（用 F 表示）的左孩子，直接将 P 的孩子结点作为 F 的左孩子；反之若 P 是 F 的右孩子，直接将 P 的孩子结点作为 F 的右孩子。

   > 例如，删除例子中的结点 29，它只有一个孩子结点 32。由于 29 是双亲结点 20 的右孩子，因此直接将 32 作为 20 的右孩子，这样做既删除了结点 29，整棵树还是二叉排序树。

3. P 有两个孩子：中序遍历整棵二叉排序树，在中序序列里找到 P 的直接前驱结点 S，将 P 结点修改成 S 结点，然后再将之前的 S 结点从树中摘除。

   > 在二叉排序树中，对于拥有两个孩子的结点，它的直接前驱结点要么是叶子结点，要么是没有右孩子的结点，所以删除直接前驱结点可以套用前面两种情况的实现思路。

##### 实现

```java
public boolean delete(int value) {

        Node current = root;
        Node parent = root;
        boolean isLeft = false;
        boolean isRight = false;
        //查找所要删除的节点的左子节点还是右子节点
        while(current.val != value) {
            parent = current;
            isLeft = false;
            isRight = false;
            if(value < current.val) {
                current = current.leftChild;
                isLeft = true;
            }
            else {
                current = current.rightChild;
                isRight = true;
            }
        }
        //不存在该值
        if(current == null) {
            return false;
        }
        //是叶子节点，不存在子节点
        if((current.leftChild == null) 
            && (current.rightChild == null)) {
            System.out.println("是叶子节点，不存在子节点");
            if(isLeft) {
                //如果是左子节点，设父节点的左子节点为null
                parent.leftChild = null;
            }
            else if(isRight) {
                //如果是右子节点，设父节点的右子节点为null
                parent.rightChild = null;
            }
            return  true;
        }
        //存在左子节点
        else if((current.leftChild != null) 
                && (current.rightChild == null)) {
                System.out.println("不是叶子节点，存在左子节点");

                if(isLeft) {
                    parent.leftChild = current.leftChild;
                }
                else if(isRight) {
                    parent.rightChild = current.leftChild;
                }
                current = null;
                return  true;
        }

        //存在右子节点
        else if((current.leftChild == null) 
                && (current.rightChild != null)) {
                System.out.println("不是叶子节点，存在右子节点");                
                if(isLeft) {
                    parent.leftChild = current.rightChild; 

                }
                else if(isRight) {
                    parent.rightChild = current.rightChild; 
                }
                current = null;
                return  true;
        }
        //左右子节点都存在
        else {
            System.out.println("不是叶子节点，存在左右子节点");

            if(isLeft) {
                parent.leftChild = current.rightChild; 

                Node currentLeft = current.rightChild;
                Node parentLeft = currentLeft;
                while(currentLeft != null) {
                    parentLeft = currentLeft;
                    currentLeft = currentLeft.leftChild;
                }
                parentLeft.leftChild = current.leftChild;
                current = null;

            }
            else if(isRight) {
                parent.rightChild = current.rightChild; 

                Node currentLeft = current.rightChild;
                Node parentLeft = currentLeft;
                while(currentLeft != null) {
                    parentLeft = currentLeft;
                    currentLeft = currentLeft.leftChild;
                }
                parentLeft.leftChild = current.leftChild;
                current = null;
            }

            return  true;
        }
    }
```

#### 时间复杂度

- 二叉查找树查找、插入、删除的时间复杂度为O(log<sub>2</sub>N)
- 二叉查找树最差极端的情况，就是会变成一种线性链表似的结构，此时时间复杂度就变味了O（N）

#### 缺点

容易出现平衡问题，二叉搜索树在经过多次插入与删除后，有可能导致平衡问题，导致搜索性能下降，近似线性。

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/261dc0dcebeb473381c9897889da9b4e~noop.image)

### 平衡二叉树AVL

平衡二叉树，又称为 AVL 树，实际上就是遵循以下两个特点的二叉树：

- 每棵子树中的左子树和右子树的深度差不能超过 1；
- 二叉树中每棵子树都要求是平衡二叉树；

> 其实就是在二叉树的基础上，若树中每棵子树都满足其左子树和右子树的深度差都不超过 1，则这棵二叉树就是平衡二叉树。

**平衡因子**：每个结点都有其各自的平衡因子，表示的就是其左子树深度同右子树深度的差。平衡二叉树中各结点平衡因子的取值只可能是：0、1 和 -1。

![image-20231113160928363](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20231113160928363.png)

> （a） 的两棵二叉树中由于各个结点的平衡因子数的绝对值都不超过 1，所以 （a） 中两棵二叉树都是平衡二叉树；
>
>  （b） 的两棵二叉树中有结点的平衡因子数的绝对值超过 1，所以都不是平衡二叉树。

#### 平衡

当二叉树不平衡的时候，可以通过“旋转”来使它平衡

- 左旋转（适用于右子树高度 - 左子树高度 > 1）
- 右旋转（适用于左子树高度 - 右子树高度 > 1）
- 双旋转

##### 左旋

旋转后，

- 根结点：最新的根结点的右孩子为原根结点的右孩子

- 左子树：左子树的根即为原来的根，左子树的左子树即为原来的左子树，左子树的右子树为原来右子树的左子树

- 右子树：右子树为原根结点右孩子的右子树

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20190903142924827.png)

【思路】

1. 创建一个新的节点，且其值等于二叉树根节点的值
2. 把新节点的左子树设置成当前节点的左子树
3. 把新节点的右子树设置成当前节点右子树的左子树
4. 把当前节点的值设置成其右子节点的值
5. 把当前节点的右子树设置成其右子树的右子树
6. 把当前节点的左子树设置成新节点

```java
		/**
	 * 左旋
	 * @param node
	 * @return
	 */
	public AVLNode leftRotation(AVLNode node) {
		
		if(node != null) {
			AVLNode rightChild = node.rightChild;
			node.rightChild = rightChild.leftChild;
			if(rightChild.leftChild != null) {
				rightChild.leftChild.parent = node;
			}
			rightChild.parent = node.parent;
			if(node.parent == null) {
				this.root = rightChild;
			}
			else if(node.parent.rightChild == node) {
				node.parent.rightChild = rightChild;
			}
			else if(node.parent.leftChild == node) {
				node.parent.leftChild = rightChild;
			}
			rightChild.leftChild = node;
			node.parent = rightChild;
			return rightChild;
		}
		
		return null;
	}
```

##### 右旋

旋转后，

- 根结点：最新的根结点的左孩子为原根结点的右孩子
- 左子树：左子树为原根结点左孩子的左子树
- 右子树：右子树的根即为原来的根，右子树的右子树即为原来的右子树，右子树的左子树为原来左子树的右子树

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2019090314311613.png)

【思路】

1. 创建一个新的节点，且其值等于二叉树根节点的值
2. 把新节点的右子树设置成当前节点的右子树
3. 把新节点的左子树设置成当前节点左子树的右子树
4. 把当前节点的值设置成其左子节点的值
5. 把当前节点的左子树设置成其左子树的左子树
6. 把当前节点的右子树设置成新节点

```java
/**
	 * 右旋
	 * @param node
	 * @return
	 */
	public AVLNode rightRotation(AVLNode node) {
		if(node != null) {
			
			AVLNode leftChild = node.leftChild;
			node.leftChild = leftChild.rightChild;
			// 如果leftChild的右节点存在，则需将该右节点的父节点指给node节点
			if(leftChild.rightChild != null) {  
				leftChild.rightChild.parent = node;
			}
			leftChild.parent = node.parent;
			if(node.parent == null) {
				this.root = leftChild;
			}
			else if(node.parent.rightChild == node) {  // 即node节点在它原父节点的右子树中
				node.parent.rightChild = leftChild;
			}
			else if(node.parent.leftChild == node) {
				node.parent.leftChild = leftChild;
			}
			
			leftChild.rightChild = node;
			node.parent = leftChild;
			return leftChild;
		}
		
		return null;
	}
```



##### 双旋转

###### 左右旋

如果当前节点的左子树的右子树的高度大于当前节点的左子树的左子树的高度：

- 可以先对当前节点的左子树进行左旋转
- 然后对当前节点右旋转

![在这里插入图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/94d59bff46134460aa1db127c56e248d.png)

如果我们在子树b或子树c中插入一个新节点后parent节点的平衡因子变为2，此时不管是左单旋，还是右单旋，之后都不能真正解决问题。这时候需要左单旋subL，再右单旋parent。

左右旋之后因为并没有修正平衡因子，需要手动根据具体情况修正，值得注意的一点是，我们在完成操作之后，该树回到了未插入之前的高度，插入之前整棵树的高度h+2，在经过两次旋转变换之后，该树的高度仍然是h+2，所以没必要继续向上调整平衡因子。

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/0e122bb7a4234bdf84ab495a71be2e0e.png)

###### 右左旋

如果当前节点的右子树的左子树的高度大于当前节点的右子树的右子树的高度：

- 可以先对当前节点的右子树进行右旋转
- 然后对当前节点左旋转

![在这里插入图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/94d59bff46134460aa1db127c56e248d.png)

如果我们在子树b或子树c中插入一个新节点后parent节点的平衡因子变为2，此时不管是左单旋，还是右单旋，之后都不能真正解决问题，这时候需要右单旋subR，再左单旋parent。

右左旋之后因为并没有修正平衡因子，需要手动根据具体情况修正，值得注意的一点是，我们在完成操作之后，该树回到了未插入之前的高度，插入之前整棵树的高度是h+2，在经过两次旋转变换之后，该树的高度仍然是h+2，所以没必要继续向上调整平衡因子。

![在这里插入图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/6149ae36c28344bb8b75bb757f938fe6.png)

##### 实现

```java
    /**
	 * 计算node节点的BF值
	 * @param node
	 * @return
	 */
	public int calcNodeBalanceValue(AVLNode node) {
		if(node != null) {
			return getHeightByNode(node);
		}
		return 0;
	}
	
	private int getHeightByNode(AVLNode node) {
		if(node == null) {
			return 0;
		}
		return getChildDepth(node.leftChild) - getChildDepth(node.rightChild);
	}
	
	private int getChildDepth(AVLNode node) {
		if(node == null) {
			return 0;
		}
		return 1 + Math.max(getChildDepth(node.leftChild), getChildDepth(node.rightChild));
	}

	/**
	 * 平衡二叉树的方法
	 * @param node
	 */
	public void rebuild(AVLNode node) {
		while(node != null) {
			if(calcNodeBalanceValue(node) == MAX_LEFT) {
				fixAfterInsertion(node, LEFT);
			}
			else if(calcNodeBalanceValue(node) == MAX_RIGHT) {
				fixAfterInsertion(node, RIGHT);
			}
			node = node.parent;
		}
	}

     /**
	 * 调整树的结构
	 * @param node
	 * @param type
	 */
	public void fixAfterInsertion(AVLNode node, int type) {
		if(type == LEFT) {
			AVLNode leftChild = node.leftChild;
			if(leftChild.leftChild != null) {  //右旋
				rightRotation(node);
			}
			else if(leftChild.rightChild != null) {   //左右旋
				leftRotation(leftChild);
				rightRotation(node);
			}
		}
		else if(type == RIGHT) {
			AVLNode rightChild = node.rightChild;
			if(rightChild.rightChild != null) {   //左旋
				leftRotation(node);
			}
			else if(rightChild.leftChild != null) {   //右左旋
				rightRotation(rightChild);
				leftRotation(node);
			}
		}
	}	
```

#### 查找

##### 思路

同二叉查找树。

##### 实现

```java
/**
	 * 获得指定节点
	 * @param key
	 * @return
	 */
	public AVLNode getNode(int key) {
	
		AVLNode node = root;
		int t;
		do {
			t = node.data - key;
			if(t > 0) {
				node = node.leftChild;
			}
			else if(t < 0) {
				node = node.rightChild;
			}
			else {
				return node;
			}
		} while(node != null);
		return null;
	}
```

#### 插入

##### 思路

同二叉查找树。只是额外多了rebuild重建平衡的阶段。

##### 实现

```java
/**
	 * 插入节点
	 * @param data
	 */
	public void put(int data) {
		putData(root, data);
	}
	
	private boolean putData(AVLNode node, int data) {
		if(node == null) {
			node  = new AVLNode(data);
			root = node;
			return true;
		}
		int t;
		AVLNode p;
		AVLNode temp = node;
		do {
			p = temp;
			t = temp.data - data;
			if(t < 0) {
				temp = temp.rightChild;
			}
			else if(t > 0) {
				temp = temp.leftChild;
			}
			else {
				return false;
			}
		} while(temp != null);
		
		if(t < 0) {
			p.rightChild = new AVLNode(p, data);
		}
		else if(t > 0) {
			p.leftChild = new AVLNode(p, data);
		}
		rebuild(p);
		return true;
		
	}
```

#### 删除

##### 思路

同二叉查找树。只是额外多了rebuild重建平衡的阶段。

##### 实现

```java
/**
	 * 删除指定val值的节点
	 * @param val
	 * @return
	 */
	public boolean delete(int val) {
		AVLNode node = getNode(val);
		if(node == null) {
			return false;
		}
		boolean flag = false;
		AVLNode p = null;
		AVLNode parent = node.parent;
		AVLNode leftChild = node.leftChild;
		AVLNode rightChild = node.rightChild;
		if(leftChild == null && rightChild == null) {
			if(parent != null) {
				if(parent.leftChild == node) {
					parent.leftChild = null;
				}
				else if(parent.rightChild == node) {
					parent.rightChild = null;
				}
			}
			else {
				this.root = null;
			}
			
			p = parent;
			node = null;
			flag = true;
		}
		else if(leftChild == null && rightChild != null) {
			if(parent != null && parent.data > val) {
				parent.leftChild = rightChild;
			}
			else if(parent != null && parent.data < val) {
				parent.rightChild = rightChild;
			}
			else {
				this.root = rightChild;
			}
			p = parent;
			node = null;
			flag = true;
		}
		else if(leftChild != null && rightChild == null) {
			if(parent != null &&  parent.data > val) {
				parent.leftChild = leftChild;
			}
			else if(parent != null && parent.data < val) {
				parent.rightChild = leftChild;
			}
			else {
				this.root = leftChild;
			}
			
			p = parent;
			node = null;
			flag = true;
		}
		else if(leftChild != null && rightChild != null) {
			AVLNode successor = getSuccessor(node);
			int tempData = successor.data;
			if(delete(tempData)) {
				node.data = tempData;
			}
			p = successor;
			successor = null;
			flag = true;
		}
		
		if(flag) {
			this.rebuild(p);
		}
		return flag;	
	}
```

#### 时间复杂度

- 平衡二叉树在添加和删除时需要进行复杂的旋转保持整个树的平衡，插入、查找的时间复杂度都是O(log<sub>2</sub>N)

#### 缺点

AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。

每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。

### 红黑树

![在这里插入图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/20190409222157219.png)

#### 红黑规则

1. 节点不是黑色，就是红色（非黑即红）
2. 根节点为黑色
3. 叶节点为黑色（叶节点是指末梢的空节点 `Nil`或`Null`）
4. 一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）
5. 每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）

其中：

- 约束4和5，保证了红黑树的**大致平衡**：根到叶子的所有路径中，最长路径不会超过最短路径的2倍。

- 默认新插入的节点为红色：因为父节点为黑色的概率较大，插入新节点为红色，可以避免颜色冲突

- 红黑树在最长路径下也会有O(log<sub>2</sub>N)的查找效率

  > 黑色高度为3时
  >
  > 最短路径：黑色→ 黑色 →黑色
  >
  > 最长路径：黑色→ 红色 →→ 黑色 →  红色 → 黑色

#### 红黑树的定义

```java
class RedBlackTreeNode {
    public int val;
    public RedBlackTreeNode left;
    public RedBlackTreeNode right;
    // 记录节点颜色的color属性，暂定true表示红色
    public boolean color;
    // 为了方便迭代插入，所需的parent属性
    public RedBlackTreeNode parent;

    // 一些构造函数，根据实际需求构建
    public RedBlackTreeNode() {
    }
}
```

红黑树要多一个颜色属性

[红黑树详解_晓之木初的博客-CSDN博客](https://blog.csdn.net/u014454538/article/details/120120216)

#### 总结

**有了二叉搜索树，为什么还需要平衡二叉树？**

- 在学习二叉搜索树、平衡二叉树时，二叉搜索树容易退化成一条链，时间复杂度从O(log<sub>2</sub>N)退化成O(N)
- 引入对左右子树高度差有限制的平衡二叉树，保证查找操作的最坏时间复杂度也为O(log<sub>2</sub>N)

**有了平衡二叉树，为什么还需要红黑树？**

- AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡
- 在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
- 红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL：
  - 红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决
  - 红黑树的红黑规则，保证最坏的情况下O(log<sub>2</sub>N)完成查找操作

## 多叉树

[图解B树的原理及操作_b树原理-CSDN博客](https://blog.csdn.net/jinking01/article/details/115130286)

### B树

B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是二叉查找树。

一颗m阶的B树定义如下：

1）每个结点最多有m-1个关键字。

2）根结点最少可以只有1个关键字。

3）非根结点至少有`（[向上取整(m/2)]-1）`个关键字。

4）每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

5）所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。

![clip_image002](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/b3bb4102e782679b8ea45a9037fe0186.png)

在实际应用中的B树的阶数m都非常大（通常大于100），所以即使存储大量的数据，B树的高度仍然比较小。

### B+树









