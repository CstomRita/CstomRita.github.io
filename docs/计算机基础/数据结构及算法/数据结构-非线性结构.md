@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>

## 二叉树

![image-20231113161334671](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231113161334671.png)

### 满二叉树

![image-20231113161411098](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231113161411098.png)

所有内部节点都有两个子节点，最底一层是叶子节点。

- 如果一颗树深度为h，最大层数为k，且深度与最大层数相同，即k=h;

- 第k层的结点数是：2^(k-1)

- 总结点数是：2^k-1 (2的k次方减一)

- 总节点数一定是奇数。

- 树高：h=log2(n+1)

### 完全二叉树

![image-20231113161530195](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231113161530195.png)

若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h 层所有的结点都连续集中在最左边，这就是完全二叉树。

- 深度为k的完全二叉树，至少有2^(k-1)个节点，至多有2^k-1个节点。

- 树高h=log2n + 1

- 满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树

### 二叉查找树BST

二叉排序树本质是一棵二叉树，它的特别之处在于：

- 对于树中的每个结点，如果它有左子树，那么左子树上所有结点的值都比该结点小；
- 对于树中的每个结点，如果它有右子树，那么右子树上所有结点的值都比该结点大

![image-20231113145341762](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231113145341762.png)

```java
class Node{
  Object data;
  Node left;
  Node right;
}
```

#### 查找

##### 思路

在二叉排序树中查找目标元素，就是从树根结点出发，先将树根结点和目标元素做比较：

- 若当前结点不存在，则查找失败；若当前结点的值和目标元素相等，则查找成功；
- 若当前结点的值比目标元素大，目标元素只可能位于当前结点的左子树中，继续进入左子树查找；
- 若当前结点的值比目标元素小，目标元素只可能位于当前结点的右子树中，继续进入右子树查找；

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/2-220H51210144P.gif)

以上图的二叉排序树为例，查找元素 32 的过程是：

- 从树根结点出发，41 比目标元素 32 大，则 32 只可能位于 41 的左子树中，继续进入左子树查找；
- 当前子树的根结点 20 比目标元素 32 小，则 32 只可能位于 20 的右子树中，继续进入右子树查找；
- 当前子树的根结点 29 比目标元素 32 小，则 32 只可能位于 29 的右子树中，继续进入右子树查找；
- 当前子树只有一个根结点 32，和目标元素相等，正是要找的目标元素

##### 实现

```java
public Node find(int value) {

    Node current = root;

    while(current.val != value) {

        if(value < current.val) {
            current = current.leftChild;
        }
        else {
            current = current.rightChild;
        }
        if(current == null) {
            return null;
        }
    }

    return current;
}
```

#### 插入

##### 思路

二叉排序树中各个结点的值都不相等，因此新插入的元素一定是原二叉排序树没有的，否则插入操作会失败。此外插入新元素后，必须保证整棵树还是一棵二叉排序树。

二叉排序树插入新元素的方法是：在树中查找新元素，最终查找失败时找到的位置，就是放置新元素的位置。

在上图的二叉排序树中插入新元素 30，在树中查找 30，最终查找失败时找到的位置是结点 32 的左孩子，直接将 30 作为 32 的左孩子即可。

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/2-220H5121024301.gif)

##### 实现

```java
public void insert(int data) {
        Node  newNode = new Node();
        newNode.val = data;     
        if(root == null) {
            //如果是第一个节点，也就是根节点为null,直接创建一个新的节点即可　
            root = newNode;
        }
        else {
            Node current = root;
            //current节点的父节点
            Node parent;
            //循环查找插入的位置
            while(true) {
                parent = current;
                //如果插入的值小于当前节点的值，从左子树查找
                if(data < current.val) {
                    current = current.leftChild;
                    //直到当前节点为null
                    if(current == null) {
                        //设置当前节点的父节点的左子节点为新创建的节点
                        parent.leftChild = newNode;
                        return;
                    }

                }
                //如果插入的值大于当前节点的值，从左子树查找
                else {
                    current = current.rightChild;
                    //直到当前节点为null
                    if(current == null) {
                        //设置当前节点的父节点的右子节点为新创建的节点
                        parent.rightChild = newNode;
                        return;
                    }
                }
            }// end of while(true)
        }   
    }
```



#### 删除

##### 思路

删除二叉排序树中已有的元素，必须确保整棵树还是一棵二叉排序树。

假设被删除的元素是 P，删除的同时需要妥善处理它的左、右子树。根据结点 P 是否有左、右孩子，可以归结为以下 3 种情况：

1. P 是叶子结点：可以直接摘除，整棵树还是二叉排序树。

2. P 只有一个孩子（左孩子或右孩子）：若 P 是双亲结点（用 F 表示）的左孩子，直接将 P 的孩子结点作为 F 的左孩子；反之若 P 是 F 的右孩子，直接将 P 的孩子结点作为 F 的右孩子。

   > 例如，删除例子中的结点 29，它只有一个孩子结点 32。由于 29 是双亲结点 20 的右孩子，因此直接将 32 作为 20 的右孩子，这样做既删除了结点 29，整棵树还是二叉排序树。

3. P 有两个孩子：中序遍历整棵二叉排序树，在中序序列里找到 P 的直接前驱结点 S，将 P 结点修改成 S 结点，然后再将之前的 S 结点从树中摘除。

   > 在二叉排序树中，对于拥有两个孩子的结点，它的直接前驱结点要么是叶子结点，要么是没有右孩子的结点，所以删除直接前驱结点可以套用前面两种情况的实现思路。

##### 实现

```java
public boolean delete(int value) {

        Node current = root;
        Node parent = root;
        boolean isLeft = false;
        boolean isRight = false;
        //查找所要删除的节点的左子节点还是右子节点
        while(current.val != value) {
            parent = current;
            isLeft = false;
            isRight = false;
            if(value < current.val) {
                current = current.leftChild;
                isLeft = true;
            }
            else {
                current = current.rightChild;
                isRight = true;
            }
        }
        //不存在该值
        if(current == null) {
            return false;
        }
        //是叶子节点，不存在子节点
        if((current.leftChild == null) 
            && (current.rightChild == null)) {
            System.out.println("是叶子节点，不存在子节点");
            if(isLeft) {
                //如果是左子节点，设父节点的左子节点为null
                parent.leftChild = null;
            }
            else if(isRight) {
                //如果是右子节点，设父节点的右子节点为null
                parent.rightChild = null;
            }
            return  true;
        }
        //存在左子节点
        else if((current.leftChild != null) 
                && (current.rightChild == null)) {
                System.out.println("不是叶子节点，存在左子节点");

                if(isLeft) {
                    parent.leftChild = current.leftChild;
                }
                else if(isRight) {
                    parent.rightChild = current.leftChild;
                }
                current = null;
                return  true;
        }

        //存在右子节点
        else if((current.leftChild == null) 
                && (current.rightChild != null)) {
                System.out.println("不是叶子节点，存在右子节点");                
                if(isLeft) {
                    parent.leftChild = current.rightChild; 

                }
                else if(isRight) {
                    parent.rightChild = current.rightChild; 
                }
                current = null;
                return  true;
        }
        //左右子节点都存在
        else {
            System.out.println("不是叶子节点，存在左右子节点");

            if(isLeft) {
                parent.leftChild = current.rightChild; 

                Node currentLeft = current.rightChild;
                Node parentLeft = currentLeft;
                while(currentLeft != null) {
                    parentLeft = currentLeft;
                    currentLeft = currentLeft.leftChild;
                }
                parentLeft.leftChild = current.leftChild;
                current = null;

            }
            else if(isRight) {
                parent.rightChild = current.rightChild; 

                Node currentLeft = current.rightChild;
                Node parentLeft = currentLeft;
                while(currentLeft != null) {
                    parentLeft = currentLeft;
                    currentLeft = currentLeft.leftChild;
                }
                parentLeft.leftChild = current.leftChild;
                current = null;
            }

            return  true;
        }
    }
```

#### 时间复杂度

- 二叉查找树查找、插入、删除的时间复杂度为O(log<sub>2</sub>N)
- 二叉查找树最差极端的情况，就是会变成一种线性链表似的结构，此时时间复杂度就变味了O（N）

#### 缺点

容易出现平衡问题，二叉搜索树在经过多次插入与删除后，有可能导致平衡问题，导致搜索性能下降，近似线性。

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/261dc0dcebeb473381c9897889da9b4enoop.image)

### 平衡二叉树AVL

平衡二叉树，又称为 AVL 树，实际上就是遵循以下两个特点的二叉树：

- 每棵子树中的左子树和右子树的深度差不能超过 1；
- 二叉树中每棵子树都要求是平衡二叉树；

> 其实就是在二叉树的基础上，若树中每棵子树都满足其左子树和右子树的深度差都不超过 1，则这棵二叉树就是平衡二叉树。

**平衡因子**：每个结点都有其各自的平衡因子，表示的就是其左子树深度同右子树深度的差。平衡二叉树中各结点平衡因子的取值只可能是：0、1 和 -1。

![image-20231113160928363](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231113160928363.png)

> （a） 的两棵二叉树中由于各个结点的平衡因子数的绝对值都不超过 1，所以 （a） 中两棵二叉树都是平衡二叉树；
>
>  （b） 的两棵二叉树中有结点的平衡因子数的绝对值超过 1，所以都不是平衡二叉树。

#### 平衡

当二叉树不平衡的时候，可以通过“旋转”来使它平衡

- 左旋转（适用于右子树高度 - 左子树高度 > 1）
- 右旋转（适用于左子树高度 - 右子树高度 > 1）
- 双旋转

##### 左旋

旋转后，

- 根结点：最新的根结点的右孩子为原根结点的右孩子

- 左子树：左子树的根即为原来的根，左子树的左子树即为原来的左子树，左子树的右子树为原来右子树的左子树

- 右子树：右子树为原根结点右孩子的右子树

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/20190903142924827.png)

【思路】

1. 创建一个新的节点，且其值等于二叉树根节点的值
2. 把新节点的左子树设置成当前节点的左子树
3. 把新节点的右子树设置成当前节点右子树的左子树
4. 把当前节点的值设置成其右子节点的值
5. 把当前节点的右子树设置成其右子树的右子树
6. 把当前节点的左子树设置成新节点

```java
		/**
	 * 左旋
	 * @param node
	 * @return
	 */
	public AVLNode leftRotation(AVLNode node) {
		
		if(node != null) {
			AVLNode rightChild = node.rightChild;
			node.rightChild = rightChild.leftChild;
			if(rightChild.leftChild != null) {
				rightChild.leftChild.parent = node;
			}
			rightChild.parent = node.parent;
			if(node.parent == null) {
				this.root = rightChild;
			}
			else if(node.parent.rightChild == node) {
				node.parent.rightChild = rightChild;
			}
			else if(node.parent.leftChild == node) {
				node.parent.leftChild = rightChild;
			}
			rightChild.leftChild = node;
			node.parent = rightChild;
			return rightChild;
		}
		
		return null;
	}
```

##### 右旋

旋转后，

- 根结点：最新的根结点的左孩子为原根结点的右孩子
- 左子树：左子树为原根结点左孩子的左子树
- 右子树：右子树的根即为原来的根，右子树的右子树即为原来的右子树，右子树的左子树为原来左子树的右子树

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/2019090314311613.png)

【思路】

1. 创建一个新的节点，且其值等于二叉树根节点的值
2. 把新节点的右子树设置成当前节点的右子树
3. 把新节点的左子树设置成当前节点左子树的右子树
4. 把当前节点的值设置成其左子节点的值
5. 把当前节点的左子树设置成其左子树的左子树
6. 把当前节点的右子树设置成新节点

```java
/**
	 * 右旋
	 * @param node
	 * @return
	 */
	public AVLNode rightRotation(AVLNode node) {
		if(node != null) {
			
			AVLNode leftChild = node.leftChild;
			node.leftChild = leftChild.rightChild;
			// 如果leftChild的右节点存在，则需将该右节点的父节点指给node节点
			if(leftChild.rightChild != null) {  
				leftChild.rightChild.parent = node;
			}
			leftChild.parent = node.parent;
			if(node.parent == null) {
				this.root = leftChild;
			}
			else if(node.parent.rightChild == node) {  // 即node节点在它原父节点的右子树中
				node.parent.rightChild = leftChild;
			}
			else if(node.parent.leftChild == node) {
				node.parent.leftChild = leftChild;
			}
			
			leftChild.rightChild = node;
			node.parent = leftChild;
			return leftChild;
		}
		
		return null;
	}
```



##### 双旋转

###### 左右旋

如果当前节点的左子树的右子树的高度大于当前节点的左子树的左子树的高度：

- 可以先对当前节点的左子树进行左旋转
- 然后对当前节点右旋转

![在这里插入图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/94d59bff46134460aa1db127c56e248d.png)

如果我们在子树b或子树c中插入一个新节点后parent节点的平衡因子变为2，此时不管是左单旋，还是右单旋，之后都不能真正解决问题。这时候需要左单旋subL，再右单旋parent。

左右旋之后因为并没有修正平衡因子，需要手动根据具体情况修正，值得注意的一点是，我们在完成操作之后，该树回到了未插入之前的高度，插入之前整棵树的高度h+2，在经过两次旋转变换之后，该树的高度仍然是h+2，所以没必要继续向上调整平衡因子。

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/0e122bb7a4234bdf84ab495a71be2e0e.png)

###### 右左旋

如果当前节点的右子树的左子树的高度大于当前节点的右子树的右子树的高度：

- 可以先对当前节点的右子树进行右旋转
- 然后对当前节点左旋转

![在这里插入图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/94d59bff46134460aa1db127c56e248d-1699924165402.png)

如果我们在子树b或子树c中插入一个新节点后parent节点的平衡因子变为2，此时不管是左单旋，还是右单旋，之后都不能真正解决问题，这时候需要右单旋subR，再左单旋parent。

右左旋之后因为并没有修正平衡因子，需要手动根据具体情况修正，值得注意的一点是，我们在完成操作之后，该树回到了未插入之前的高度，插入之前整棵树的高度是h+2，在经过两次旋转变换之后，该树的高度仍然是h+2，所以没必要继续向上调整平衡因子。

![在这里插入图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/6149ae36c28344bb8b75bb757f938fe6.png)

##### 实现

```java
    /**
	 * 计算node节点的BF值
	 * @param node
	 * @return
	 */
	public int calcNodeBalanceValue(AVLNode node) {
		if(node != null) {
			return getHeightByNode(node);
		}
		return 0;
	}
	
	private int getHeightByNode(AVLNode node) {
		if(node == null) {
			return 0;
		}
		return getChildDepth(node.leftChild) - getChildDepth(node.rightChild);
	}
	
	private int getChildDepth(AVLNode node) {
		if(node == null) {
			return 0;
		}
		return 1 + Math.max(getChildDepth(node.leftChild), getChildDepth(node.rightChild));
	}

	/**
	 * 平衡二叉树的方法
	 * @param node
	 */
	public void rebuild(AVLNode node) {
		while(node != null) {
			if(calcNodeBalanceValue(node) == MAX_LEFT) {
				fixAfterInsertion(node, LEFT);
			}
			else if(calcNodeBalanceValue(node) == MAX_RIGHT) {
				fixAfterInsertion(node, RIGHT);
			}
			node = node.parent;
		}
	}

     /**
	 * 调整树的结构
	 * @param node
	 * @param type
	 */
	public void fixAfterInsertion(AVLNode node, int type) {
		if(type == LEFT) {
			AVLNode leftChild = node.leftChild;
			if(leftChild.leftChild != null) {  //右旋
				rightRotation(node);
			}
			else if(leftChild.rightChild != null) {   //左右旋
				leftRotation(leftChild);
				rightRotation(node);
			}
		}
		else if(type == RIGHT) {
			AVLNode rightChild = node.rightChild;
			if(rightChild.rightChild != null) {   //左旋
				leftRotation(node);
			}
			else if(rightChild.leftChild != null) {   //右左旋
				rightRotation(rightChild);
				leftRotation(node);
			}
		}
	}	
```

#### 查找

##### 思路

同二叉查找树。

##### 实现

```java
/**
	 * 获得指定节点
	 * @param key
	 * @return
	 */
	public AVLNode getNode(int key) {
	
		AVLNode node = root;
		int t;
		do {
			t = node.data - key;
			if(t > 0) {
				node = node.leftChild;
			}
			else if(t < 0) {
				node = node.rightChild;
			}
			else {
				return node;
			}
		} while(node != null);
		return null;
	}
```

#### 插入

##### 思路

同二叉查找树。只是额外多了rebuild重建平衡的阶段。

##### 实现

```java
/**
	 * 插入节点
	 * @param data
	 */
	public void put(int data) {
		putData(root, data);
	}
	
	private boolean putData(AVLNode node, int data) {
		if(node == null) {
			node  = new AVLNode(data);
			root = node;
			return true;
		}
		int t;
		AVLNode p;
		AVLNode temp = node;
		do {
			p = temp;
			t = temp.data - data;
			if(t < 0) {
				temp = temp.rightChild;
			}
			else if(t > 0) {
				temp = temp.leftChild;
			}
			else {
				return false;
			}
		} while(temp != null);
		
		if(t < 0) {
			p.rightChild = new AVLNode(p, data);
		}
		else if(t > 0) {
			p.leftChild = new AVLNode(p, data);
		}
		rebuild(p);
		return true;
		
	}
```

#### 删除

##### 思路

同二叉查找树。只是额外多了rebuild重建平衡的阶段。

##### 实现

```java
/**
	 * 删除指定val值的节点
	 * @param val
	 * @return
	 */
	public boolean delete(int val) {
		AVLNode node = getNode(val);
		if(node == null) {
			return false;
		}
		boolean flag = false;
		AVLNode p = null;
		AVLNode parent = node.parent;
		AVLNode leftChild = node.leftChild;
		AVLNode rightChild = node.rightChild;
		if(leftChild == null && rightChild == null) {
			if(parent != null) {
				if(parent.leftChild == node) {
					parent.leftChild = null;
				}
				else if(parent.rightChild == node) {
					parent.rightChild = null;
				}
			}
			else {
				this.root = null;
			}
			
			p = parent;
			node = null;
			flag = true;
		}
		else if(leftChild == null && rightChild != null) {
			if(parent != null && parent.data > val) {
				parent.leftChild = rightChild;
			}
			else if(parent != null && parent.data < val) {
				parent.rightChild = rightChild;
			}
			else {
				this.root = rightChild;
			}
			p = parent;
			node = null;
			flag = true;
		}
		else if(leftChild != null && rightChild == null) {
			if(parent != null &&  parent.data > val) {
				parent.leftChild = leftChild;
			}
			else if(parent != null && parent.data < val) {
				parent.rightChild = leftChild;
			}
			else {
				this.root = leftChild;
			}
			
			p = parent;
			node = null;
			flag = true;
		}
		else if(leftChild != null && rightChild != null) {
			AVLNode successor = getSuccessor(node);
			int tempData = successor.data;
			if(delete(tempData)) {
				node.data = tempData;
			}
			p = successor;
			successor = null;
			flag = true;
		}
		
		if(flag) {
			this.rebuild(p);
		}
		return flag;	
	}
```

#### 时间复杂度

- 平衡二叉树在添加和删除时需要进行复杂的旋转保持整个树的平衡，插入、查找的时间复杂度都是O(log<sub>2</sub>N)

#### 缺点

AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL 树为了维持这种高度的平衡，就要付出更多的代价。

每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。

### 红黑树

![在这里插入图片描述](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/20190409222157219.png)

#### 红黑规则

1. 节点不是黑色，就是红色（非黑即红）
2. 根节点为黑色
3. 叶节点为黑色（叶节点是指末梢的空节点 `Nil`或`Null`）
4. 一个节点为红色，则其两个子节点必须是黑色的（根到叶子的所有路径，不可能存在两个连续的红色节点）
5. 每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同的黑色高度）

其中：

- 约束4和5，保证了红黑树的**大致平衡**：根到叶子的所有路径中，最长路径不会超过最短路径的2倍。

- 默认新插入的节点为红色：因为父节点为黑色的概率较大，插入新节点为红色，可以避免颜色冲突

- 红黑树在最长路径下也会有O(log<sub>2</sub>N)的查找效率

  > 黑色高度为3时
  >
  > 最短路径：黑色→ 黑色 →黑色
  >
  > 最长路径：黑色→ 红色 →→ 黑色 →  红色 → 黑色

#### 红黑树的定义

```java
class RedBlackTreeNode {
    public int val;
    public RedBlackTreeNode left;
    public RedBlackTreeNode right;
    // 记录节点颜色的color属性，暂定true表示红色
    public boolean color;
    // 为了方便迭代插入，所需的parent属性
    public RedBlackTreeNode parent;

    // 一些构造函数，根据实际需求构建
    public RedBlackTreeNode() {
    }
}
```

红黑树要多一个颜色属性

#### 平衡

##### 左旋

左旋需要三大步（被旋转的节点叫做节点P）：

1. 空出右儿子的左子树： （对应下图步骤2）
- 右儿子的左子树取代右儿子，成为节点P的右子树，从而空出右儿子的左子树

- 若右儿子的左子树不为空，需要更新左子树的父节点为节点P
2. 空出节点P的父节点： （对应下图步骤3）
- 右儿子去取代节点P，成为其父节点的子树
- 父节点指向右儿子
     - 若父节点为null，root将指向右儿子，右儿子成为整棵树的根节点；
     - 节点P是父节点的左子树，则右儿子成为父节点的左儿子；
     - 节点P是父节点的右子树，则右儿子成为父节点的右儿子

3. 节点P和右儿子成功会师： （对应下图步骤4）
- 上述两步，空出了节点P的父节点和右儿子的左子树。
- 这时直接更新，即可将节点P变成右儿子的左子树。

![image-20231114100149385](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114100149385.png)

```java
public void leftRotate(RedBlackTreeNode p) {
    // 在当前节点不为null时，才进行左旋操作
    if (p != null) {
        // 先记录p的右儿子
        RedBlackTreeNode rightChild = p.right;

        // 1. 空出右儿子的左子树
        p.right = rightChild.left;
        // 左子树不为空，需要更新父节点
        if (rightChild.left != null) {
            rightChild.left.parent = p;
        }

        // 2. 空出节点p的父节点
        rightChild.parent = p.parent;
        // 父节点指向右儿子
        if (p.parent == null) { // 右儿子成为新的根节点
            this.root = rightChild;
        } else if (p == p.parent.left) { // 右儿子成为父节点的左儿子
            p.parent.left = rightChild;
        } else { // 右儿子成为父节点的右儿子
            p.parent.right = rightChild;
        }

        // 3. 右儿子和节点p成功会师，节点p成为左子树
        rightChild.left = p;
        p.parent = rightChild;
    }
}
```

##### 右旋

右旋需要三大步（被旋转节点称为节点P）：

1. 空出左儿子的右子树： （对应下图步骤2）

- 左儿子的右子树取代左儿子，成为节点P的左子树，以空出左儿子的右子树
- 若左儿子的右子树不为空，需要更新右子树的父节点为节点P

2. 空出节点P的父节点： （对应下图步骤3）

- 左儿子取代节点P，成为其父节点的子树
- 父节点指向左儿子：
  - 父节点为空，root将指向左儿子，左儿子成为整棵树的根节点
  - 节点P为父节点的左子树，左儿子成为父节点的左子树
  - 节点P为父节点的右子树，左儿子成为节点P的右子树

3. 节点P和左儿子成功会师： （对应下图步骤4）

- 上述两步，空出了节点P的父节点和左儿子的右子树。
- 这时直接更新，即可将节点P成左儿子的右子树

![image-20231114100124943](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114100124943.png)

```java
public void rightRotate(RedBlackTreeNode p) {
    if (p != null) {
        // 记录p的左儿子
        RedBlackTreeNode leftChild = p.left;

        // 1. 空出左儿子的右子树
        p.left = leftChild.right;
        // 右子树不为空，需要更新父节点
        if (leftChild.right != null) {
            leftChild.right.parent = p;
        }

        // 2. 空出节点p的父节点
        leftChild.parent = p.parent;
        // 父节点指向左儿子
        if (p.parent == null) { // 左儿子成为整棵树根节点
            this.root = leftChild;
        } else if (p.parent.left == p) { // 左儿子成为父节点左儿子
            p.parent.left = leftChild;
        } else { // 左儿子成为父节点的右儿子
            p.parent.right = leftChild;
        }

        // 3. 顺利会师
        leftChild.right = p;
        p.parent = leftChild;
    }
}
```

#### 插入

- 新插入的节点默认为红色，原因：插入黑色节点会影响黑色高度，对红黑树的影响更大；
- 新增节点x时，循环的依据： x != null && x != root && x.parent.color == RED，即节点非空、不是整棵树的根节点（保证存在父节点）且父节点为红色（违反红黑规则4，需要调整）
- 完成循环调整后，需要将整棵树的根节点设为黑色，以满足红黑规则1；同时，根节点设为黑色，不会影响从根节点开始的所有路径的黑色高度

> [!tip]
>
> - 循环条件： x != null && x != root && x.parent.color == RED，即节点非空、不是整棵树的根节点（保证存在父节点）且父节点为红色
> - 最终处理：将整棵树的根节点变成黑色，以满足红黑规则1，又不会违反红黑规则5
> - 对父亲是祖父的左儿子或右儿子的处理是对称的，只需要理解左儿子时的处理方法，就可以举一反三，知道对右儿子的处理方法
>
> 1. 父亲为祖父的左儿子：
>
> - 父叔同色，只进行变色操作
> - 父叔异色，自己是右儿子，则进行LR操作
> - 父叔异色，自己是左儿子，则进行R操作
>
> 2. 父亲为祖父的右儿子
>
> - 父叔同色，只进行变色操作
> - 父叔异色，自己是左儿子，则进行RL操作
> - 父叔异色，自己是右儿子，则进行L操作

##### 父亲为祖父的左儿子

###### 情况1 父亲和叔叔都是红色 

当父亲为祖父的左儿子，父亲和叔叔都是红色时：

1. 将父亲和叔叔改成黑色，以满足红黑规则4
2. 父亲和叔叔变成黑色了，黑色高度变化，需要将祖父变成红色，以满足红黑规则5
3. 从祖父开始，继续调整

![image-20231114100839439](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114100839439.png)

###### 情况2 叔叔为黑色，自己是父亲的左儿子 

父亲为祖父的左儿子，叔叔为黑色，自己是父亲的左儿子

1. 父亲变成黑色，祖父变成红色（右子树的黑色高度变低）
2. 对祖父进行右旋，让父节点成为新的祖父，以恢复右子树的黑色高度
3. 不满足循环条件，退出循环

![image-20231114100923317](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114100923317.png)

###### 情况3 叔叔为黑色，自己是父亲的右儿子

父亲为祖父的左儿子，叔叔为黑色，自己是父亲的右儿子

1. 父亲成为新的x，对父亲进行左旋操作，构造情况二的初始状态
2. 按照情况二，对新的x（原父亲）进行处理

![image-20231114101016634](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114101016634.png)

##### 父亲为祖父的右儿子

###### 情况1 父亲和叔叔都是红色 

父亲为祖父的右儿子，父亲和叔叔都是红色

1. 将父亲和叔叔都变成黑色，以保证红黑规则4
2. 将祖父变成红色，以保证红色规则5（相同的黑色高度）
3. 从祖父开始，继续调整

![image-20231114101225065](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114101225065.png)

###### 情况2 叔叔为黑色，自己是父亲的右儿子 

父亲为祖父的右儿子，叔叔为黑色，自己是父亲的右儿子

1. 父亲变成黑色，祖父变成红色（左子树的黑色高度降低）
2. 对祖父进行左旋操作，以恢复左子树的黑色高度
3. 不满足循环条件，退出循环

![image-20231114101313550](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114101313550.png)

###### 情况3 叔叔为黑色，自己是父亲的右儿子

父亲是祖父的右儿子，叔叔为黑色，自己是父亲的左儿子

1. 父节点成为新的X，对父亲进行右旋操作，构造情况二的初始情况
2. 按照情况二，对新的x（原父节点）进行处理

![image-20231114101401944](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114101401944.png)

##### 实现

```java
public void fixAfterInsert(RedBlackTreeNode x) {
    // 新插入的节点，默认为红色
    x.color = RED;

    // p不为null、不是整棵树的根节点、父亲为红色，需要调整
    while (x != null && this.root != x && x.parent.color == RED) {
        // 父亲是祖父的左儿子
        if (parentOf(x) == parentOf(parentOf(x)).left) {
            // 父亲和叔叔都是红色
            RedBlackTreeNode uncle = parentOf(parentOf(x)).right;
            if (uncle.color == RED) {
                // 父亲和叔叔都变成黑色
                parentOf(x).color = BLACK;
                uncle.color = BLACK;
                // 祖父变成红色，继续从祖父开始进行调整
                parentOf(parentOf(x)).color = RED;
                x = parentOf(parentOf(x));
            } else { // 叔叔为黑色
                // 自己是父亲的右儿子，需要对父亲左旋
                if (x == parentOf(x).right) {
                    x = parentOf(x);
                    leftRotate(x);
                }
                // 自己是父亲的左儿子，变色后右旋，保持黑色高度
                parentOf(x).color = BLACK;
                parentOf(parentOf(x)).color = RED;
                rightRotate(parentOf(parentOf(x)));
            }
        } else { //父亲是祖父的右儿子
            RedBlackTreeNode uncle = parentOf(parentOf(x)).left;
            // 父亲和叔叔都是红色
            if (uncle.color == RED) {
                // 叔叔和父亲变成黑色
                parentOf(x).color = BLACK;
                uncle.color = BLACK;
                // 祖父变为红色，从祖父开始继续调整
                parentOf(parentOf(x)).color = RED;
                x = parentOf(parentOf(x));
            } else {
                // 自己是父亲的左儿子，以父亲为中心右旋
                if (parentOf(x).left == x) {
                    x = parentOf(x);
                    rightRotate(x);
                }
                // 自己是父亲的右儿子，变色后左旋，保持黑色高度
                parentOf(x).color = BLACK;
                parentOf(parentOf(x)).color = RED;
                leftRotate(parentOf(parentOf(x)));
            }
        }
    }

    // 最后将根节点置为黑色，以满足红黑规则1，又不会破坏规则5
    this.root.color = BLACK;
}

private static RedBlackTreeNode parentOf(RedBlackTreeNode p) {
    return (p == null ? null : p.parent);
}
```



#### 删除

- 删除节点时，通过节点替换实现删除
- 假设替换节点为x，需要在x替换被删节点后，从x开始进行调整
- 调整操作，循环的依据： x != root && x.color == BLACK，即替换节点不能为整棵树的根节点，替换节点的颜色为黑色（改变了红黑高度）
- 完成循环调整后，需要将x设为黑色，结束调整

> [!tip]
>
> - 循环条件：`x != root && x.color = BLACK`，x不是根节点且颜色为黑色
> - 收尾操作：将x置为黑色
> - x为父亲的左儿子或右儿子，处理操作是对称的；同样只需要记住左儿子时的操作，即可举一反三
>
> 1. x为父亲的左儿子
>
> - 兄弟为红色：将兄弟变成黑色，父节点变成红色；对父节点左旋，恢复左子树的黑色高度，左侄子成为新的兄弟
> - 兄弟为黑色，左右侄子为黑色：兄弟变成红色，x指向父节点，继续进行调整
> - 兄弟为黑色，右侄子为黑色（左侄子为红色）：左侄子变成黑色，兄弟变成红色；兄弟右旋，恢复右子树的黑色高度，左侄子成为新的兄弟
> - 兄弟为黑色，右侄子为红色：兄弟变成父节点颜色，父节点和右侄子变成黑色；父节点左旋，x指向整棵树的根节点，结束循环
>2. x为父亲的左儿子
>
> - 兄弟为红色：将兄弟变成黑色，父节点变成红色；对父节点右旋，恢复右子树的黑色高度，右侄子成为新的兄弟
> - 兄弟为黑色，左右侄子为黑色：兄弟变成红色，x指向父节点，继续进行调整
> - 兄弟为黑色，左侄子为黑色：右侄子变成黑色，兄弟变成红色；兄弟左旋，恢复左子树的黑色高度，右侄子成为新的兄弟
> - 兄弟为黑色，左侄子为红色：兄弟变成父节点颜色，父节点和左侄子变成黑色；父节点右旋，x指向整棵树的根节点，结束循环

##### x为父亲的左儿子 

###### 情况1 兄弟为红色 

- 此时，自己为黑色、兄弟为红色、父节点为黑色（满足红黑规则4）
  1. 将兄弟变成黑色，父节点变成红色；这时，以父节点为起点的左子树黑色高度降低
  2. 对父节点进行左旋，以恢复左子树黑色高度；同时，兄弟的左孩子成为新的兄弟
- 此时，自己和兄弟都是黑色，可能满足满足情况2、3和4、4

![image-20231114102454780](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114102454780.png)

###### 情况2 兄弟为黑色，左右侄子也是黑色

此时，自己和兄弟都是黑色，父节点为黑色或红色；兄弟的两个儿子，都是黑色

1. 将兄弟变成为红色，x指向父节点，继续进行调整

![image-20231114102558267](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114102558267.png)

###### 情况3 兄弟为黑色，右侄子为黑色 

- 此时，自己和兄弟均为黑色，父节点为红色或黑色；右侄子为黑色、左侄子为红色；
  1. 将左侄子变成黑色，兄弟变为红色；这时，以兄弟为起点的右子树黑色高度降低
  2. 将兄弟节点右旋，以恢复右子树的黑色高度；这时，左侄子将成为新的右兄弟
- 此时，兄弟的右儿子为红色，满足情况4；继续按照情况4，对节点x进行调整

![image-20231114102657892](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114102657892.png)

###### 情况4兄弟为黑色，右侄子为红色

此时，自己和兄弟都是黑色，父节点为红色或黑色；右侄子为红色，左侄子为黑色或红色

1. 兄弟颜色改成与父节点一致，右侄子和父节点都变成黑色
2. 为了保证父节点变为黑色后，不影响所有路径的黑色高度，需要将父节点左旋（兄弟节点上提）
3. x指向根节点，结束循环

![image-20231114102736903](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114102736903.png)

##### x为父亲的右儿子

###### 情况1 兄弟为红色 

- 此时，兄弟是红色节点，父节点必为黑色；若兄弟有左右儿子，左右儿子必为黑色（满足红黑规则4）
  1. 将兄弟变成黑色节点，父节点变成红色；这时，以父节点为起点的右子树黑色高度降低
  2. 将父节点右旋，以恢复右子树的黑色高度；这时，兄弟的右孩子成为新的兄弟

- 此时，自己和兄弟都是黑色，将满足情况2、3和4、4


![image-20231114102832864](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114102832864.png)

###### 情况2 兄弟为黑色，左右侄子也是黑色

此时，自己和兄弟是黑色，父节点可以为红色或黑色

1. 将兄弟变成红色，x指向父节点，继续对父节点进行调整

![image-20231114102914010](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114102914010.png)

###### 情况3 兄弟为黑色，右侄子为黑色 

- 此时，自己和兄弟均为黑色，父节点为黑色或红色；左侄子为黑色，右侄子为红色
  1. 将右侄子变成黑色，兄弟变成红色；这是，以兄弟为起点的左子树黑色高度降低
  2. 将兄弟左旋，以恢复左子树的黑色高度；这时，右侄子成为新的兄弟
- 此时，将满足情况4，可以按照情况4，继续进行调整

![image-20231114102949805](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114102949805.png)

###### 情况4兄弟为黑色，右侄子为红色

此时，自己和兄弟均为黑色，父节点为红色或黑色；左侄子为红色，右侄子为红色或黑色

1. 将兄弟变成与父节点一样的颜色，左侄子和父节点变成黑色
2. 为了保证父节点变成黑色，不会影响所有路径的黑色高度，需要将父节点右旋（兄弟上提）
3. x指向根节点，退出循环

![image-20231114103025046](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114103025046.png)

##### 实现

```java
public void fixAfterDeletion(RedBlackTreeNode x) {
    // x不是根节点且颜色为黑色，开始循环调整
    while (x != root && x.color == BLACK) {
        // x是父亲的左儿子
        if (x == parentOf(x).left) {
            RedBlackTreeNode brother = parentOf(x).right;
            // 兄弟为红色
            if (brother.color == RED) {
                // 兄弟变成黑色，父节点变成红色
                brother.color = BLACK;
                parentOf(x).color = RED;
                // 父节点左旋，恢复左子树的黑色高度
                leftRotate(parentOf(x));
                // 更新兄弟
                brother = parentOf(x).right;
            }

            // 兄弟为黑色，左右侄子为黑色
            if (brother.left.color == BLACK && brother.right.color == BLACK) {
                // 兄弟变成红色
                brother.color = RED;
                // 从父节点开始继续调整
                x = parentOf(x);
            } else {
                // 右侄子为黑色（左侄子为红色）
                if (brother.right.color == BLACK) {
                    // 左侄子变为黑色，兄弟变成红色
                    brother.left.color = BLACK;
                    brother.color = RED;
                    // 兄弟右旋，恢复右子树黑色高度
                    rightRotate(brother);
                    // 左侄子成为新的兄弟
                    brother = parentOf(x).right;
                }
                // 右侄子为红色，兄弟变成父节点颜色
                brother.color = parentOf(x).color;
                // 父节点和右侄子变成黑色
                parentOf(x).color = BLACK;
                brother.right.color = BLACK;
                // 父节点左旋
                leftRotate(parentOf(x));
                // x指向根节点
                x = root;
            }
        } else {
            RedBlackTreeNode brother = parentOf(x).left;
            // 兄弟为红色
            if (brother.color == RED) {
                // 兄弟变黑色，父亲变红色
                brother.color = BLACK;
                parentOf(x).color = RED;
                // 父亲右旋，恢复红黑色高度
                rightRotate(parentOf(x));
                // 更新兄弟为右侄子
                brother = parentOf(x).left;
            }

            // 兄弟的左右儿子为黑色
            if (brother.left.color == BLACK && brother.right.color == BLACK) {
                // 兄弟变为红色
                brother.color = RED;
                // x指向父节点，继续进行调整
                x = parentOf(x);
            } else {
                // 左侄子为黑色(右侄子为红色)
                if (brother.left.color == BLACK) {
                    // 右侄子变黑色，兄弟变红色
                    brother.right.color = BLACK;
                    brother.color = RED;
                    // 对兄弟左旋
                    leftRotate(brother);
                    // 右侄子成为新的兄弟
                    brother = parentOf(x).left;
                }

                // 左侄子为红色，兄弟改为父节点颜色
                brother.color = parentOf(x).color;
                // 父节点和左侄子变成黑色
                brother.left.color = BLACK;
                parentOf(x).color = BLACK;
                // 兄弟节点上提(右旋父节点)
                rightRotate(parentOf(x));
                // x指向根节点
                x = root;
            }

        }
    }
    // 更新x为黑色
    x.color = BLACK;
}
```

#### 总结

##### 二叉搜索VS AVL VS 红黑树

**有了二叉搜索树，为什么还需要平衡二叉树？**

- 在学习二叉搜索树、平衡二叉树时，二叉搜索树容易退化成一条链，时间复杂度从O(log<sub>2</sub>N)退化成O(N)
- 引入对左右子树高度差有限制的平衡二叉树，保证查找操作的最坏时间复杂度也为O(log<sub>2</sub>N)

**有了平衡二叉树，为什么还需要红黑树？**

- AVL的左右子树高度差不能超过1，每次进行插入/删除操作时，几乎都需要通过旋转操作保持平衡
- 在频繁进行插入/删除的场景中，频繁的旋转操作使得AVL的性能大打折扣
- 红黑树通过牺牲严格的平衡，换取插入/删除时少量的旋转操作，整体性能优于AVL：
  - <font color=red>**红黑树插入时的不平衡，不超过两次旋转就可以解决；删除时的不平衡，不超过三次旋转就能解决**</font>
  - 红黑树的红黑规则，保证最坏的情况下O(log<sub>2</sub>N)完成查找操作

##### TreeMap源码解析

[Java TreeMap 源码解析 - Robert Peng's Blog (mr-dai.github.io)](https://mr-dai.github.io/java_collection_treemap/#平衡树操作-——-查找)

## 多叉树

### B树

B树也称B-树,它是一颗多路平衡查找树。我们描述一颗B树时需要指定它的阶数，阶数表示了一个结点最多有多少个孩子结点，一般用字母m表示阶数。当m取2时，就是二叉查找树。

一颗m阶的B树定义如下：

1）每个结点最多有m-1个关键字。

2）根结点最少可以只有1个关键字。

3）非根结点至少有`（[向上取整(m/2)]-1）`个关键字。

4）每个结点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。

5）所有叶子结点都位于同一层，或者说根结点到每个叶子结点的长度都相同。

![clip_image002](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/b3bb4102e782679b8ea45a9037fe0186.png)

在实际应用中的B树的阶数m都非常大（通常大于100），所以即使存储大量的数据，B树的高度仍然比较小。

#### 插入

##### 思路

1）根据要插入的key的值，找到叶子结点并插入。

2）判断当前结点key的个数是否小于等于m-1，若满足则结束，否则进行第3步。

3）以结点中间的key为中心分裂成左右两部分，然后将这个中间的key插入到父结点中，这个key的左子树指向分裂后的左半部分，这个key的右子支指向分裂后的右半部分，然后将当前结点指向父结点，继续进行第3步。

##### 例子

下面以5阶B树为例，介绍B树的插入操作，在5阶B树中，结点最多有4个key,最少有2个key

a）在空树中插入39

![clip_image002[4]](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/00b7b35c56cfae3b3fca9192e037b8da.png)

此时根结点就一个key，此时根结点也是叶子结点

b）继续插入22，97和41

![clip_image004](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/2c3d3eef6949352d6623f5b42f27e23e.png)

根结点此时有4个key

c）继续插入53

![clip_image006](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/c5d941d4ccce2fae3caa55446f7fdd5e.png)

插入后超过了最大允许的关键字个数4，所以以key值为41为中心进行分裂，结果如下图所示，分裂后当前结点指针指向父结点，满足B树条件，插入操作结束。当阶数m为偶数时，需要分裂时就不存在排序恰好在中间的key，那么我们选择中间位置的前一个key或中间位置的后一个key为中心进行分裂即可。

![clip_image008](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/1a79aa30f06011e3a7d2a88765dc2f7d.png)

d）依次插入13，21，40，同样会造成分裂，结果如下图所示。

![clip_image010](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/a191724e3371adf3e3cb2818ad9188dc.png)

e）依次插入30，27, 33 ；36，35，34 ；24，29，结果如下图所示。

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/20210323165614280.png)

 

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/20210323165928625.png)

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/20210323170233301.png)

继续插入，最终为：

![clip_image012](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/72847c3e3fc3ecc73050488baf8a00f7.png)

f）插入key值为26的记录，插入后的结果如下图所示。

![clip_image014](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/23ea8a46d94aa4c949eac01a21cb0993.png)

当前结点需要以27为中心分裂，并向父结点进位27，然后当前结点指向父结点，结果如下图所示。

![clip_image016](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/f5a2f35cb4f6a75171957edaad4e5789.png)

进位后导致当前结点（即根结点）也需要分裂，分裂的结果如下图所示。

![clip_image018](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/5da848ef54298540211893f25d296fc7.png)

分裂后当前结点指向新的根，此时无需调整。

g）最后再依次插入key为17,28,29,31,32的记录，结果如下图所示。

![clip_image020](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/f5349af0cd2ceec6c8c2100a40ee4a6d.png)




#### 删除

##### 思路

1）如果当前需要删除的key位于非叶子结点上，则用后继key（这里的后继key均指后继记录的意思）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子结点上，这个过程和二叉搜索树删除结点的方式类似。删除这个记录后执行第2步。

2）该结点key个数大于等`（[向上取整(m/2)]-1）`，结束删除操作，否则执行第3步。

3）如果兄弟结点key个数大`（[向上取整(m/2)]-1）`，则父结点中的key下移到该结点，兄弟结点中的一个key上移，删除操作结束。否则，将父结点中的key下移与当前结点及它的兄弟结点中的key合并，形成一个新的结点。原父结点中的key的两个孩子指针就变成了一个孩子指针，指向这个新结点。然后当前结点的指针指向父结点，重复上第2步。

##### 例子

下面以5阶B树为例，介绍B树的删除操作，5阶B树中，结点最多有4个key,最少有2个key

a）原始状态

![clip_image021](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/40887dcb6f02935ff8886d66847409d1.png)

b）在上面的B树中删除21，删除后结点中的关键字个数仍然大于等2，所以删除结束。

![clip_image023](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/f8da74adc69a8bc8ef345eb7737405cc.png)

c）在上述情况下接着删除27。从上图可知27位于非叶子结点中，所以用27的后继替换它。从图中可以看出，27的后继为28，我们用28替换27，然后在28（原27）的右孩子结点中删除28。删除后的结果如下图所示。

![clip_image025](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/f44ccc19eea10d200c3774f89eb42329.png)

删除后发现，当前叶子结点的记录的个数小于2，而它的兄弟结点中有3个记录（当前结点还有一个右兄弟，选择右兄弟就会出现合并结点的情况，不论选哪一个都行，只是最后B树的形态会不一样而已），我们可以从兄弟结点中借取一个key。所以父结点中的28下移，兄弟结点中的26上移,删除结束。结果如下图所示。

![clip_image027](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/48e5b9c9254f1792df91bd4cdca866bc.png)

d）在上述情况下接着32，结果如下图。

![clip_image029](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/c095b6aaf74ee424f33bae685c60b8b6.png)

当删除后，当前结点中只key，而兄弟结点中也仅有2个key。所以只能让父结点中的30下移和这个两个孩子结点中的key合并，成为一个新的结点，当前结点的指针指向父结点。结果如下图所示。

![clip_image031](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/0f0c05ee4e79ec6ba517f8e178d3d150.png)

当前结点key的个数满足条件，故删除结束。

e）上述情况下，我们接着删除key为40的记录，删除后结果如下图所示。

![clip_image033](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/42de6581810d178a4b1964b7d1f08159.png)

同理，当前结点的记录数小于2，兄弟结点中没有多余key，所以父结点中的key下移，和兄弟（这里我们选择左兄弟，选择右兄弟也可以）结点合并，合并后的指向当前结点的指针就指向了父结点。

![clip_image035](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/0f9544464eb2edf35854c12a02b91a02.png)

同理，对于当前结点而言只能继续合并了，最后结果如下所示。

![clip_image037](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/2260a9b82005a48b0b709d943797fc10.png)

合并后结点当前结点满足条件，删除结束。


### B+树

B+树还有以下的要求：

1. B+树包含2种类型的结点：内部结点（也称索引结点）和叶子结点。根结点本身即可以是内部结点，也可以是叶子结点。根结点的关键字个数最少可以只有1个。
2. B+树与B树最大的不同是内部结点不保存数据，只用于索引，<font color=red>**所有数据（或者说记录）都保存在叶子结点中。**</font>

3. m阶B+树表示了内部结点最多有m-1个关键字（或者说内部结点最多有m个子树），阶数m同时限制了叶子结点最多存储m-1个记录。

4. 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。

5. <font color=red>**每个叶子结点都存有相邻叶子结点的指针**</font>，叶子结点本身依关键字的大小自小而大顺序链接。

![clip_image039](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/eba89b7fb850be843ed7b39396173bd4.png)

#### 插入

##### 思路

1）若为空树，创建一个叶子结点，然后将记录插入其中，此时这个叶子结点也是根结点，插入操作结束。

2）针对叶子类型结点：根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。将当前结点的指针指向父结点，然后执行第3步。

3）针对索引类型结点：若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key，右结点包含m-(m-1)/2个key，将第m/2个key进位到父结点中，进位到父结点的key左孩子指向左结点, 进位到父结点的key右孩子指向右结点。将当前结点的指针指向父结点，然后重复第3步。

##### 例子

下面是一颗5阶B树的插入过程，5阶B数的结点最少2个key，最多4个key。

a）空树中插入5

![clip_image041](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/16f5c9d8cf555c323519b8ff2ec161b1.png)

b）依次插入8，10，15

![clip_image043](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/6b7660f92c3e2235d4c1a61adc6db7e7.png)

c）插入16

![clip_image045](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/8cdef99653a0da4a01f37e16014d994a.png)

插入16后超过了关键字的个数限制，所以要进行分裂。在叶子结点分裂时，分裂出来的左结点2个记录，右边3个记录，中间key成为索引结点中的key，分裂后当前结点指向了父结点（根结点）。结果如下图所示。

![clip_image047](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/551fe728ba4ec1c61f97105d2c1788d5.png)

当然我们还有另一种分裂方式，给左结点3个记录，右结点2个记录，此时索引结点中的key就变为15。

d）插入17

![clip_image049](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/6fb246132497adbcbb92b6dcbcd1da20.png)

e）插入18，插入后如下图所示

![clip_image051](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/0b5b34168deff772f8a1799322592fcb.png)

当前结点的关键字个数大于5，进行分裂。分裂成两个结点，左结点2个记录，右结点3个记录，关键字16进位到父结点（索引类型）中，将当前结点的指针指向父结点。

![clip_image053](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/72350ae51d1d407929657169d109b374.png)

当前结点的关键字个数满足条件，插入结束。

f）插入若干数据后

![clip_image055](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/1954e754ef75c0005b2b6cd2c0ce26b5.png)

g）在上图中插入7，结果如下图所示

![clip_image057](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/6bee1acb73d9c3312e07b4adfe4bcac8.png)

当前结点的关键字个数超过4，需要分裂。左结点2个记录，右结点3个记录。分裂后关键字7进入到父结点中，将当前结点的指针指向父结点，结果如下图所示。

![clip_image059](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/564f5ce12d9498011e9484237804b240.png)

当前结点的关键字个数超过4，需要继续分裂。左结点2个关键字，右结点2个关键字，关键字16进入到父结点中，将当前结点指向父结点，结果如下图所示。

![clip_image061](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/46264c2e4aaabb2795e232a1db6fb031.png)

当前结点的关键字个数满足条件，插入结束。

#### 删除

##### 思路

如果叶子结点中没有相应的key，则删除失败。否则执行下面的步骤

1）删除叶子结点中对应的key。删除后若结点的key的个数大于等于Math.ceil(m-1)/2 – 1，删除操作结束,否则执行第2步。

2）若兄弟结点key有富余（大于Math.ceil(m-1)/2 – 1），向兄弟结点借一个记录，同时用借到的key替换父结（指当前结点和兄弟结点共同的父结点）点中的key，删除结束。否则执行第3步。

3）若兄弟结点中没有富余的key,则当前结点和兄弟结点合并成一个新的叶子结点，并删除父结点中的key（父结点中的这个key两边的孩子指针就变成了一个指针，正好指向这个新的叶子结点），将当前结点指向父结点（必为索引结点），执行第4步（第4步以后的操作和B树就完全一样了，主要是为了更新索引结点）。

4）若索引结点的key的个数大于等于Math.ceil(m-1)/2 – 1，则删除操作结束。否则执行第5步

5）若兄弟结点有富余，父结点key下移，兄弟结点key上移，删除结束。否则执行第6步

6）当前结点和兄弟结点及父结点下移key合并成一个新的结点。将当前结点指向父结点，重复第4步。

注意，通过B+树的删除操作后，索引结点中存在的key，不一定在叶子结点中存在对应的记录。

##### 例子

下面是一颗5阶B树的删除过程，5阶B数的结点最少2个key，最多4个key。

a）初始状态

![clip_image063](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/6fb25083af5f09dfad275cc9025fee6b.png)

b）删除22,删除后结果如下图

![clip_image065](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/35ffca2eceeb7ac3743724d07208bb5b.png)

删除后叶子结点中key的个数大于等于2，删除结束

c）删除15，删除后的结果如下图所示

![clip_image067](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/affd36f23cf13287952d008471fc5d97.png)

删除后当前结点只有一个key,不满足条件，而兄弟结点有三个key，可以从兄弟结点借一个关键字为9的记录,同时更新将父结点中的关键字由10也变为9，删除结束。

![clip_image069](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/63587fa765ab43048d97bbf8bcb0acc0.png)

d）删除7，删除后的结果如下图所示

![clip_image071](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/b6f4ca7d6ecec3d483d3b6f4f511dac5.png)

当前结点关键字个数小于2，（左）兄弟结点中的也没有富余的关键字（当前结点还有个右兄弟，不过选择任意一个进行分析就可以了，这里我们选择了左边的），所以当前结点和兄弟结点合并，并删除父结点中的key，当前结点指向父结点。

![clip_image073](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/6edb209d114fc8c4c5225fe8a292aae1.png)

此时当前结点的关键字个数小于2，兄弟结点的关键字也没有富余，所以父结点中的关键字下移，和两个孩子结点合并，结果如下图所示。

![clip_image075](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/3499e52fb57c3f0b463c6b10d880ae42.png)

#### B+ VS B树

- **B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。**

-  **B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。**

  根据空间局部性原理：如果一个存储器的某个位置被访问，那么将它附近的位置也会被访问。

  由于B+树的叶子节点的数据都是使用链表连接起来的，而且他们在磁盘里是顺序存储的，所以当读到某个值的时候，磁盘预读原理就会提前把这些数据都读进内存，使得范围查询和排序都很快。

- **由于B树的节点都存了key和data，而B+树只有叶子节点存data，非叶子节点都只是索引值，没有实际的数据，这就时B+树在一次IO里面，能读出的索引值更多，从而减少查询时候需要的IO次数**

  由于B-树节点内部每个 key 都带着 data 域，而B+树节点只存储 key 的副本，真实的 key 和 data 域都在叶子节点存储。前面说过磁盘是分 block 的，一次磁盘 IO 会读取若干个 block，具体和操作系统有关，那么由于磁盘 IO 数据大小是固定的，在一次 IO 中，单个元素越小，量就越大。这就意味着B+树单次磁盘 IO 的信息量大于B-树，从这点来看B+树相对B-树磁盘 IO 次数少。

  

## 哈希树

> [!tip]哈希树可以广泛应用于那些需要对大容量数据进行快速匹配操作的地方。例如：数据库索引系统、短信息中的收条匹配、大量号码路由匹配、信息过滤匹配。

### 哈希树HashTree

哈希树(HashTree)算法就是要提供一种在理论上和实际应用中均能有效地处理冲突的方法。一般的哈希(Hash)算法都是O(1)的，而且基本是以空间换时间。这很容易导致对存储空间无限制的需求。

哈希树(HashTree)算法在实际操作中使用了一些技巧使得对空间的需求控制在一定范围内。即 空间需求仅和所需要存储的对象个数有关，不会无限制地“膨胀”下去。

#### 质数分辨定理

<font color=red>**n个不同的质数可以“分辨”的连续整数的个数和他们的乘积相等。**</font>

“分辨”就是指这些连续的整数不可能有完全相同的余数序列。

#### 插入

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/20150603103842199)

选择从2开始的连续质数来建立一个十层的哈希树:

- 第一层结点为根结点，根结点下有2个结点；

- 第二层的每个结点下有3个结点；

- 依此类推，即每层结点的子节点数目为连续的质数。到第十层，每个结点下有29个结点。

- 同一结点中的子结点，从左到右代表不同的余数结果。
  例如：第二层结点下有三个子节点。那么从左到右分别代表：除3余0，除3余1，除3余2.

<font color=red>**对质数进行取余操作得到的余数决定了处理的路径。**</font>

#### 查找

  哈希树的节点查找过程和节点插入过程类似，就是 对关键字用质数序列取余，根据余数确定下一节点的分叉路径，直到找到目标节点。

如上图，最小”哈希树(HashTree)在从4G个对象中找出所匹配的对象，比较次数不超过10次。也就是说：最多属于O(10)。

在实际应用中，调整了质数的范围，使得比较次数一般不超过5次。也就是说：最多属于O(5)。因此可以根据自身需要在时间和空间上寻求一个平衡点。

#### 删除

哈希树的节点删除过程也很简单，哈希树在删除的时候，并不做任何结构调整。

只是先查到到要删除的节点，然后把此节点的“占位标记”置为false即可（即表示此节点为空节点，但 并不进行物理删除）

#### 分析

- 结构简单：每层节点的子节点个数为连续的质数。子节点可以随时创建
- 单向增加的结构：随着所需要存储的数据量增加而增大。即使数据量减少到原来的数量，但是哈希树的总节点数不会减少。这样做的目的是为了避免结构的调整带来的额外消耗
- 查找迅速：**哈希树的查找次数和元素个数没有关系**。如果元素的连续关键字总个数在计算机的整数（32bit）所能表达的最大范围内，那么比较次数就最多不会超过10次，通常低于这个数值。
- 结构不变：哈希树**在删除的时候，并不做任何结构调整**
- 非排序性：哈希树不支持排序，没有顺序特性。如果在此基础上不做任何改进的话并试图通过遍历来实现排序，那么操作效率将远远低于其他类型的数据结构。

### 字典树Trie

Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。

**前缀树的3个基本性质：**

1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符都不相同。

![image-20231114093053913](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114093053913.png)

可以看出：

- 每条边对应一个字母。
- 每个节点对应一项前缀。叶节点对应最长前缀，即单词本身。

![image-20231114093517877](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114093517877.png)

```java
class TrieNode {			// 最标准写法
	boolean isWord;
	TrieNode[] children;
	
	public TrieNode {
		isWord = false;
		children = new TrieNode[26];
	}
}
```

- isWord为true的节点就是上面的图中**红色**的节点。举个例子，两个字符串"**cat**"和"**catch**"，字符`t`和字符`h`对应的节点，就是红色的(`isWord = true`)
- children很巧妙：利用了一个长度为26的TrieNode[]数组，用下标表示字符(char - 'a')，用该下标对应的值表示指向子节点的引用（看下面的图 ! ! !）。例如字符串"cat"，根节点有26个"触手"，只有c对应的那个下标(‘c’ - ‘a’ = 2)才是有值的，其余的全为null，表示这条路走不通。<font color=red>另外，如果没有a-z的限制，就不能用数组，而使用哈希表</font>。

![image-20231114093723034](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114093723034.png)

#### 查找

- 从根结点开始一次搜索；
-  取得要查找关键词的第一个字母，并根据该字母选择对应的子树并转到该子树继续进行检索；
- 在相应的子树上，取得要查找关键词的第二个字母,并进一步选择对应的子树进行检索。
- 迭代过程……
- 在某个结点处，关键词的所有字母已被取出，则读取附在该结点上的信息，即完成查找。其他操作类似处理。

> 从根开始按照单词的字母顺序向下遍历trie树，一旦发现某个节点标记不存在或者单词遍历完成而最后的节点未标记为红色，则表示该单词不存在，若最后的节点标记为红色，表示该单词存在。
>
> 如下图中：trie树中存在的就是abc、d、da、dda四个单词。在实际的问题中可以将标记颜色的标志位改为数量count等其他符合题目要求的变量。
>
> ![image-20231114093301752](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84.assets/image-20231114093301752.png)

```java
//【判断一个单词word是否完整存在于字典树中】
    // 思路：cur从根节点开始，按照word的字符一直尝试向下走：
    //  如果走到了null，说明这个word不是前缀树的任何一条路径，返回false;
    // 如果按照word顺利的走完，就要判断此时cur是否为单词尾端：如果是，返回true；如果不是，说明word仅仅是一个前缀，并不完整，返回false
    public boolean search(String word) {
        TrieNode cur = root;

        for (int i = 0; i < word.length(); i++) {
            int c = word.charAt(i) - 'a';
            if (cur.children[c] == null) {
                return false;
            }
            cur = cur.children[c];
        }
        return cur.isWord;
    }
```

#### 插入

对于一个单词，从根开始，沿着单词的各个字母所对应的树中的节点分支向下走，直到单词遍历完，将最后的节点标记为红色，表示该单词已插入trie树。

```java
//【向字典树插入单词word】
    // 思路：按照word的字符，从根节点开始，一直向下走：
    //  如果遇到null，就new出新节点；如果节点已经存在，cur顺着往下走就可以
    public void insert(String word) {
        TrieNode cur = root;                        // 先指向根节点

        for (int i = 0; i < word.length(); i++) {	// 如果是【后缀树】而不是【前缀树】，把单词倒着插就可以了，即for(len-1; 0; i--)
            int c = word.charAt(i) - 'a';           // (关键) 将一个字符用数字表示出来，并作为下标
            if (cur.children[c] == null) {
                cur.children[c] = new TrieNode();
            }
            cur = cur.children[c];
        }
        cur.isWord = true;                          // 一个单词插入完毕，此时cur指向的节点即为一个单词的结尾
    }
```

#### 分析

在trie树中查找一个关键字的时间和树中包含的结点数无关，而取决于组成关键字的字符数。而二叉查找树的查找时间和树中的结点数有关O(log<sub>2</sub>n)。
       如果要查找的关键字可以分解成字符序列且不是很长，利用trie树查找速度优于二叉查找树。

> 若关键字长度最大是5，则利用trie树，利用5次比较可以从26<sup>5</sup>＝11881376个可能的关键字中检索出指定的关键字。
>
> 利用二叉查找树至少要进行O(log<sub>2</sub>26<sup>5</sup>)次比较。

