@autoHeader: 2.1.1.1.1.1

<p align="right">update time : {docsify-updated}</p>

## 树

### 二叉查找树BST

二叉排序树本质是一棵二叉树，它的特别之处在于：

- 对于树中的每个结点，如果它有左子树，那么左子树上所有结点的值都比该结点小；
- 对于树中的每个结点，如果它有右子树，那么右子树上所有结点的值都比该结点大

![image-20231113145341762](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/image-20231113145341762.png)

```java
class Node{
  Object data;
  Node left;
  Node right;
}
```

#### 查找

##### 思路

在二叉排序树中查找目标元素，就是从树根结点出发，先将树根结点和目标元素做比较：

- 若当前结点不存在，则查找失败；若当前结点的值和目标元素相等，则查找成功；
- 若当前结点的值比目标元素大，目标元素只可能位于当前结点的左子树中，继续进入左子树查找；
- 若当前结点的值比目标元素小，目标元素只可能位于当前结点的右子树中，继续进入右子树查找；

##### 举例

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2-220H51210144P.gif)

以上图的二叉排序树为例，查找元素 32 的过程是：

- 从树根结点出发，41 比目标元素 32 大，则 32 只可能位于 41 的左子树中，继续进入左子树查找；
- 当前子树的根结点 20 比目标元素 32 小，则 32 只可能位于 20 的右子树中，继续进入右子树查找；
- 当前子树的根结点 29 比目标元素 32 小，则 32 只可能位于 29 的右子树中，继续进入右子树查找；
- 当前子树只有一个根结点 32，和目标元素相等，正是要找的目标元素

##### 实现

```java

```



##### 时间复杂度

因此查找的过程将是从**根结点到查找结点**的一条路径，最坏复杂度为O(h)，其中h为二叉查找树的高度。

#### 插入

##### 思路

二叉排序树中各个结点的值都不相等，因此新插入的元素一定是原二叉排序树没有的，否则插入操作会失败。此外插入新元素后，必须保证整棵树还是一棵二叉排序树。

二叉排序树插入新元素的方法是：在树中查找新元素，最终查找失败时找到的位置，就是放置新元素的位置。

##### 举例

在上图的二叉排序树中插入新元素 30，在树中查找 30，最终查找失败时找到的位置是结点 32 的左孩子，直接将 30 作为 32 的左孩子即可。

![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.assets/2-220H5121024301.gif)

##### 编程



##### 时间复杂度



#### 删除

##### 思路

删除二叉排序树中已有的元素，必须确保整棵树还是一棵二叉排序树。

假设被删除的元素是 P，删除的同时需要妥善处理它的左、右子树。根据结点 P 是否有左、右孩子，可以归结为以下 3 种情况：

1. P 是叶子结点：可以直接摘除，整棵树还是二叉排序树。

2. P 只有一个孩子（左孩子或右孩子）：若 P 是双亲结点（用 F 表示）的左孩子，直接将 P 的孩子结点作为 F 的左孩子；反之若 P 是 F 的右孩子，直接将 P 的孩子结点作为 F 的右孩子。

   > 例如，删除例子中的结点 29，它只有一个孩子结点 32。由于 29 是双亲结点 20 的右孩子，因此直接将 32 作为 20 的右孩子，这样做既删除了结点 29，整棵树还是二叉排序树。

3. P 有两个孩子：中序遍历整棵二叉排序树，在中序序列里找到 P 的直接前驱结点 S，将 P 结点修改成 S 结点，然后再将之前的 S 结点从树中摘除。

   > 在二叉排序树中，对于拥有两个孩子的结点，它的直接前驱结点要么是叶子结点，要么是没有右孩子的结点，所以删除直接前驱结点可以套用前面两种情况的实现思路。

##### 举例



##### 编程



##### 时间复杂度



### 平衡二叉树





### 红黑树



### B树



### B+树









